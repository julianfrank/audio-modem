<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Audio File Transfer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 100%;
            padding: 40px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .mode-selection {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
        }

        .mode-btn {
            flex: 1;
            padding: 15px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-btn:hover:not(:disabled) {
            background: #f0f4ff;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
        }

        .mode-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .mode-content {
            display: none;
        }

        .mode-content.active {
            display: block;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 500;
            font-size: 14px;
        }

        textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            min-height: 120px;
            transition: border-color 0.3s ease;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        input[type="file"] {
            width: 100%;
            padding: 12px;
            border: 2px dashed #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
        }

        input[type="file"]::-webkit-file-upload-button {
            padding: 8px 16px;
            border: none;
            background: #667eea;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
        }

        .send-btn {
            width: 100%;
            padding: 15px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .send-btn:hover:not(:disabled) {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .send-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .listening-indicator {
            text-align: center;
            padding: 30px;
            background: #f0f4ff;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .listening-icon {
            width: 60px;
            height: 60px;
            margin: 0 auto 15px;
            border: 4px solid #667eea;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .listening-text {
            color: #667eea;
            font-weight: 600;
            font-size: 16px;
        }

        .received-data {
            margin-top: 20px;
        }

        .data-display {
            background: #f9f9f9;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            min-height: 150px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #333;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .data-display.empty {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            font-style: italic;
        }

        .progress-container {
            margin-top: 20px;
            display: none;
        }

        .progress-container.active {
            display: block;
        }

        .progress-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
            color: #666;
        }

        .progress-bar-wrapper {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-details {
            margin-top: 8px;
            font-size: 12px;
            color: #999;
            text-align: center;
        }

        .status-message {
            margin-top: 15px;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            display: none;
        }

        .status-message.active {
            display: block;
        }

        .status-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-message.warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        /* Audio visualizer styles */
        .audio-visualizer {
            margin-top: 15px;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
            display: none;
        }

        .audio-visualizer.active {
            display: block;
        }

        .visualizer-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .level-meter {
            width: 100%;
            height: 40px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .level-meter-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80 0%, #22c55e 50%, #f59e0b 75%, #ef4444 100%);
            width: 0%;
            transition: width 0.1s ease-out;
        }

        .level-meter-peak {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 2px;
            background: #dc2626;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .level-meter-peak.active {
            opacity: 1;
        }

        /* Waveform canvas */
        .waveform-canvas {
            width: 100%;
            height: 60px;
            background: #1a1a1a;
            border-radius: 4px;
            display: block;
        }

        /* Button loading state */
        .send-btn.loading {
            position: relative;
            color: transparent;
            pointer-events: none;
        }

        .send-btn.loading::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            top: 50%;
            left: 50%;
            margin-left: -10px;
            margin-top: -10px;
            border: 3px solid #ffffff;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 0.8s linear infinite;
        }

        /* Enhanced button states */
        .mode-btn:active:not(:disabled) {
            transform: scale(0.98);
        }

        .send-btn:active:not(:disabled) {
            transform: translateY(0);
        }

        /* Pulse animation for listening indicator */
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.05);
            }
        }

        .listening-icon.active {
            animation: spin 1s linear infinite, pulse 2s ease-in-out infinite;
        }

        /* Smooth transitions */
        .mode-content {
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Enhanced status messages with icons */
        .status-message::before {
            margin-right: 8px;
        }

        .status-message.success::before {
            content: 'âœ“';
            font-weight: bold;
        }

        .status-message.error::before {
            content: 'âœ•';
            font-weight: bold;
        }

        .status-message.warning::before {
            content: 'âš ';
            font-weight: bold;
        }

        /* Improved file input styling */
        input[type="file"] {
            transition: border-color 0.3s ease;
        }

        input[type="file"]:hover {
            border-color: #667eea;
        }

        input[type="file"]:focus {
            outline: none;
            border-color: #667eea;
            border-style: solid;
        }

        /* Data display enhancements */
        .data-display::-webkit-scrollbar {
            width: 8px;
        }

        .data-display::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .data-display::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        .data-display::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Responsive improvements */
        @media (max-width: 768px) {
            .container {
                padding: 30px 20px;
            }

            h1 {
                font-size: 24px;
            }

            .subtitle {
                font-size: 13px;
            }

            .mode-btn {
                padding: 12px;
                font-size: 15px;
            }

            .send-btn {
                padding: 12px;
                font-size: 15px;
            }

            .waveform-canvas {
                height: 50px;
            }
        }

        @media (max-width: 600px) {
            .container {
                padding: 25px 15px;
            }

            h1 {
                font-size: 22px;
            }

            .mode-selection {
                flex-direction: column;
                gap: 10px;
            }

            .mode-btn {
                padding: 12px;
            }

            textarea {
                min-height: 100px;
            }

            .level-meter {
                height: 30px;
            }

            .waveform-canvas {
                height: 40px;
            }
        }

        @media (max-width: 400px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 20px 12px;
            }

            h1 {
                font-size: 20px;
            }

            .subtitle {
                font-size: 12px;
                margin-bottom: 20px;
            }
        }

        /* Accessibility improvements */
        .mode-btn:focus,
        .send-btn:focus,
        textarea:focus,
        input[type="file"]:focus {
            outline: 2px solid #667eea;
            outline-offset: 2px;
        }

        /* Print styles */
        @media print {
            body {
                background: white;
            }

            .container {
                box-shadow: none;
            }

            .mode-selection,
            .send-btn,
            .audio-visualizer {
                display: none;
            }
        }

        /* Sync UI Styles */
        .sync-section {
            margin-top: 20px;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
        }

        .sync-section-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
        }

        .sync-btn {
            width: 100%;
            padding: 12px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }

        .sync-btn:hover:not(:disabled) {
            background: #059669;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        }

        .sync-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .sync-btn.active {
            background: #ef4444;
        }

        .sync-btn.active:hover:not(:disabled) {
            background: #dc2626;
        }

        .sync-btn.loading {
            position: relative;
            color: transparent;
        }

        .sync-btn.loading::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            top: 50%;
            left: 50%;
            margin-left: -8px;
            margin-top: -8px;
            border: 3px solid #ffffff;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 0.8s linear infinite;
        }

        .sync-status {
            padding: 10px;
            border-radius: 6px;
            font-size: 13px;
            margin-bottom: 10px;
            display: none;
            transition: all 0.3s ease;
        }

        .sync-status.active {
            display: block;
        }

        .sync-status.idle {
            background: #f3f4f6;
            color: #6b7280;
        }

        .sync-status.transmitting {
            background: #dbeafe;
            color: #1e40af;
        }

        .sync-status.listening {
            background: #fef3c7;
            color: #92400e;
        }

        .sync-status.detected {
            background: #d1fae5;
            color: #065f46;
        }

        .sync-status.error {
            background: #fee2e2;
            color: #991b1b;
        }

        .frequency-display {
            display: none;
            margin-top: 10px;
            animation: fadeIn 0.5s ease;
        }

        .frequency-display.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .frequency-display-title {
            font-size: 12px;
            font-weight: 600;
            color: #666;
            margin-bottom: 8px;
        }

        .frequency-values {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .frequency-item {
            background: white;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
            text-align: center;
            transition: all 0.3s ease;
        }

        .frequency-item:hover {
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
            transform: translateY(-2px);
        }

        .frequency-label {
            font-size: 10px;
            color: #999;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .frequency-value {
            font-size: 16px;
            font-weight: 700;
            color: #667eea;
            font-family: 'Courier New', monospace;
        }

        .frequency-unit {
            font-size: 11px;
            color: #666;
            margin-left: 2px;
        }

        .spectrum-canvas {
            width: 100%;
            height: 120px;
            background: #1a1a1a;
            border-radius: 6px;
            margin-top: 10px;
            display: none;
            border: 2px solid #667eea;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
            animation: fadeIn 0.5s ease;
        }

        .spectrum-canvas.active {
            display: block;
        }

        .sync-help-text {
            font-size: 12px;
            color: #666;
            margin-top: 8px;
            line-height: 1.4;
        }

        /* Responsive sync UI */
        @media (max-width: 600px) {
            .frequency-values {
                grid-template-columns: 1fr;
                gap: 6px;
            }

            .spectrum-canvas {
                height: 80px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽµ Web Audio File Transfer</h1>
        <p class="subtitle">Transfer files and text using sound waves</p>

        <!-- Mode Selection -->
        <div class="mode-selection">
            <button class="mode-btn" id="emitterBtn" data-mode="emitter">
                ðŸ“¤ Emitter
            </button>
            <button class="mode-btn" id="receiverBtn" data-mode="receiver">
                ðŸ“¥ Receiver
            </button>
        </div>

        <!-- Emitter Mode UI -->
        <div class="mode-content" id="emitterMode">
            <div class="input-group">
                <label for="textInput">Enter Text:</label>
                <textarea id="textInput" placeholder="Type your message here..."></textarea>
            </div>

            <div class="input-group">
                <label for="fileInput">Or Select a File:</label>
                <div class="file-input-wrapper">
                    <input type="file" id="fileInput">
                </div>
            </div>

            <button class="send-btn" id="sendBtn" disabled>
                Send Data
            </button>

            <!-- Sync Section for Emitter -->
            <div class="sync-section">
                <div class="sync-section-title">ðŸ”„ Frequency Synchronization</div>
                <button class="sync-btn" id="emitterSyncBtn">
                    Start Sync Transmission
                </button>
                <div class="sync-status" id="emitterSyncStatus">
                    Ready to transmit calibration signal
                </div>
                <div class="sync-help-text">
                    Click to broadcast calibration tones for receiver frequency detection
                </div>
            </div>

            <!-- Audio Output Visualizer -->
            <div class="audio-visualizer" id="emitterVisualizer">
                <div class="visualizer-label">Audio Output Level</div>
                <canvas class="waveform-canvas" id="emitterWaveform" width="600" height="60"></canvas>
            </div>

            <!-- Progress Display for Emitter -->
            <div class="progress-container" id="emitterProgress">
                <div class="progress-label">
                    <span>Transmitting...</span>
                    <span id="emitterPercentage">0%</span>
                </div>
                <div class="progress-bar-wrapper">
                    <div class="progress-bar" id="emitterProgressBar"></div>
                </div>
                <div class="progress-details" id="emitterDetails">
                    0 / 0 bytes
                </div>
            </div>

            <!-- Status Messages for Emitter -->
            <div class="status-message" id="emitterStatus"></div>
        </div>

        <!-- Receiver Mode UI -->
        <div class="mode-content" id="receiverMode">
            <div class="listening-indicator">
                <div class="listening-icon"></div>
                <div class="listening-text">Listening for transmission...</div>
            </div>

            <!-- Sync Section for Receiver -->
            <div class="sync-section">
                <div class="sync-section-title">ðŸ”„ Frequency Synchronization</div>
                <button class="sync-btn" id="receiverSyncBtn">
                    Start Sync Listening
                </button>
                <div class="sync-status" id="receiverSyncStatus">
                    Ready to detect calibration signal
                </div>
                
                <!-- Spectrum Visualization Canvas -->
                <canvas class="spectrum-canvas" id="spectrumCanvas" width="600" height="120"></canvas>
                
                <!-- Frequency Display -->
                <div class="frequency-display" id="frequencyDisplay">
                    <div class="frequency-display-title">Detected Frequencies</div>
                    <div class="frequency-values">
                        <div class="frequency-item">
                            <div class="frequency-label">Bit 0</div>
                            <div class="frequency-value">
                                <span id="freq0Value">----</span>
                                <span class="frequency-unit">Hz</span>
                            </div>
                        </div>
                        <div class="frequency-item">
                            <div class="frequency-label">Preamble</div>
                            <div class="frequency-value">
                                <span id="freqPreambleValue">----</span>
                                <span class="frequency-unit">Hz</span>
                            </div>
                        </div>
                        <div class="frequency-item">
                            <div class="frequency-label">Bit 1</div>
                            <div class="frequency-value">
                                <span id="freq1Value">----</span>
                                <span class="frequency-unit">Hz</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="sync-help-text">
                    Click to listen for calibration tones and automatically detect frequencies
                </div>
            </div>

            <!-- Audio Input Visualizer -->
            <div class="audio-visualizer active" id="receiverVisualizer">
                <div class="visualizer-label">Audio Input Level</div>
                <div class="level-meter">
                    <div class="level-meter-fill" id="receiverLevelFill"></div>
                    <div class="level-meter-peak" id="receiverLevelPeak"></div>
                </div>
            </div>

            <!-- Progress Display for Receiver -->
            <div class="progress-container" id="receiverProgress">
                <div class="progress-label">
                    <span>Receiving...</span>
                    <span id="receiverPercentage">0%</span>
                </div>
                <div class="progress-bar-wrapper">
                    <div class="progress-bar" id="receiverProgressBar"></div>
                </div>
                <div class="progress-details" id="receiverDetails">
                    0 / 0 bytes
                </div>
            </div>

            <!-- Received Data Display -->
            <div class="received-data">
                <label>Received Data:</label>
                <div class="data-display empty" id="dataDisplay">
                    No data received yet
                </div>
            </div>

            <!-- Status Messages for Receiver -->
            <div class="status-message" id="receiverStatus"></div>
        </div>
    </div>

    <script>
        // Application will be implemented in subsequent tasks
        // This script section provides the structure for future implementation
        
        // Mode Controller placeholder
        class ModeController {
            constructor() {
                this.currentMode = null;
                this.isLocked = false;
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                document.getElementById('emitterBtn').addEventListener('click', () => {
                    if (!this.isLocked) {
                        this.setMode('emitter');
                    }
                });

                document.getElementById('receiverBtn').addEventListener('click', () => {
                    if (!this.isLocked) {
                        this.setMode('receiver');
                    }
                });
            }

            setMode(mode) {
                this.currentMode = mode;
                
                // Update button states
                const emitterBtn = document.getElementById('emitterBtn');
                const receiverBtn = document.getElementById('receiverBtn');
                
                emitterBtn.classList.remove('active');
                receiverBtn.classList.remove('active');
                
                if (mode === 'emitter') {
                    emitterBtn.classList.add('active');
                } else if (mode === 'receiver') {
                    receiverBtn.classList.add('active');
                }
                
                // Show/hide mode content
                document.getElementById('emitterMode').classList.remove('active');
                document.getElementById('receiverMode').classList.remove('active');
                
                if (mode === 'emitter') {
                    document.getElementById('emitterMode').classList.add('active');
                } else if (mode === 'receiver') {
                    document.getElementById('receiverMode').classList.add('active');
                }
            }

            getCurrentMode() {
                return this.currentMode;
            }

            lockMode() {
                this.isLocked = true;
                document.getElementById('emitterBtn').disabled = true;
                document.getElementById('receiverBtn').disabled = true;
            }

            unlockMode() {
                this.isLocked = false;
                document.getElementById('emitterBtn').disabled = false;
                document.getElementById('receiverBtn').disabled = false;
            }
        }

        // SyncController class - Manages synchronization state and operations
        class SyncController {
            constructor() {
                // Sync states: idle, transmitting, listening, detected, error
                this.state = 'idle';
                this.stateChangeCallbacks = [];
                this.frequenciesDetectedCallbacks = [];
                
                // References to other components (set later)
                this.calibrationGenerator = null;
                this.spectrumAnalyzer = null;
                this.frequencyDetector = null;
                this.decoderConfigurator = null;
            }

            /**
             * Start emitter sync - begin transmitting calibration signals
             */
            startEmitterSync() {
                if (this.state === 'transmitting') {
                    return; // Already transmitting
                }
                
                this.setState('transmitting');
                
                // Start calibration signal generation
                if (this.calibrationGenerator) {
                    this.calibrationGenerator.start();
                }
            }

            /**
             * Stop emitter sync - cease calibration transmission
             */
            stopEmitterSync() {
                if (this.state !== 'transmitting') {
                    return;
                }
                
                // Stop calibration signal generation
                if (this.calibrationGenerator) {
                    this.calibrationGenerator.stop();
                }
                
                this.setState('idle');
            }

            /**
             * Start receiver sync - begin listening for calibration signals
             * @returns {Promise<void>}
             */
            async startReceiverSync() {
                if (this.state === 'listening') {
                    return; // Already listening
                }
                
                this.setState('listening');
                
                // Start spectrum analysis
                if (this.spectrumAnalyzer && this.frequencyDetector) {
                    // Spectrum analysis will be handled by the receiver controller
                    // This method just updates the state
                }
            }

            /**
             * Stop receiver sync - cease listening for calibration signals
             */
            stopReceiverSync() {
                if (this.state !== 'listening' && this.state !== 'detected') {
                    return;
                }
                
                // Stop spectrum analysis
                if (this.spectrumAnalyzer) {
                    this.spectrumAnalyzer.disconnect();
                }
                
                this.setState('idle');
            }

            /**
             * Handle successful frequency detection
             * @param {Object} frequencies - Detected frequencies {preamble, bit0, bit1, confidence}
             */
            onFrequenciesDetected(frequencies) {
                this.setState('detected');
                
                // Notify all callbacks
                for (const callback of this.frequenciesDetectedCallbacks) {
                    try {
                        callback(frequencies);
                    } catch (e) {
                        console.error('Error in frequencies detected callback:', e);
                    }
                }
            }

            /**
             * Handle sync error
             * @param {string} errorMessage - Error message
             */
            onSyncError(errorMessage) {
                this.setState('error');
            }

            /**
             * Get current sync state
             * @returns {string} Current state
             */
            getSyncState() {
                return this.state;
            }

            /**
             * Set sync state and notify callbacks
             * @param {string} newState - New state to set
             */
            setState(newState) {
                const oldState = this.state;
                this.state = newState;
                
                // Notify all state change callbacks
                for (const callback of this.stateChangeCallbacks) {
                    try {
                        callback(newState, oldState);
                    } catch (e) {
                        console.error('Error in state change callback:', e);
                    }
                }
            }

            /**
             * Register callback for state changes
             * @param {Function} callback - Callback function(newState, oldState)
             */
            onStateChange(callback) {
                if (typeof callback === 'function') {
                    this.stateChangeCallbacks.push(callback);
                }
            }

            /**
             * Register callback for frequency detection
             * @param {Function} callback - Callback function(frequencies)
             */
            onFrequenciesDetectedCallback(callback) {
                if (typeof callback === 'function') {
                    this.frequenciesDetectedCallbacks.push(callback);
                }
            }

            /**
             * Set calibration generator reference
             * @param {Object} generator - CalibrationSignalGenerator instance
             */
            setCalibrationGenerator(generator) {
                this.calibrationGenerator = generator;
            }

            /**
             * Set spectrum analyzer reference
             * @param {Object} analyzer - SpectrumAnalyzer instance
             */
            setSpectrumAnalyzer(analyzer) {
                this.spectrumAnalyzer = analyzer;
            }

            /**
             * Set frequency detector reference
             * @param {Object} detector - FrequencyDetector instance
             */
            setFrequencyDetector(detector) {
                this.frequencyDetector = detector;
            }

            /**
             * Set decoder configurator reference
             * @param {Object} configurator - DecoderConfigurator instance
             */
            setDecoderConfigurator(configurator) {
                this.decoderConfigurator = configurator;
            }
        }

        // CalibrationSignalGenerator class - Generates calibration tone sequences
        class CalibrationSignalGenerator {
            constructor() {
                this.audioContext = null;
                this.sourceNode = null;
                this.isTransmitting = false;
                
                // Frequencies (Hz)
                this.freqPreamble = 5500;
                this.freq0 = 4500;
                this.freq1 = 6500;
                
                // Timing (seconds)
                this.toneDuration = 2.0;  // 2000ms
                this.silenceDuration = 0.5;  // 500ms
                
                this.sampleRate = 48000;
            }

            /**
             * Start transmitting calibration signals
             */
            start() {
                if (this.isTransmitting) {
                    return;
                }
                
                this.isTransmitting = true;
                this.playCalibrationSequence();
            }

            /**
             * Stop transmitting calibration signals
             */
            stop() {
                this.isTransmitting = false;
                
                if (this.sourceNode) {
                    try {
                        this.sourceNode.stop();
                    } catch (e) {
                        // Ignore if already stopped
                    }
                    this.sourceNode = null;
                }
                
                if (this.audioContext) {
                    this.audioContext.close();
                    this.audioContext = null;
                }
            }

            /**
             * Play the calibration sequence (loops continuously)
             */
            async playCalibrationSequence() {
                if (!this.isTransmitting) {
                    return;
                }
                
                try {
                    // Create audio context if needed
                    if (!this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                            sampleRate: this.sampleRate
                        });
                    }
                    
                    // Resume if suspended
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                    
                    // Generate calibration sequence
                    const audioBuffer = this.generateCalibrationSequence();
                    
                    // Create source node
                    this.sourceNode = this.audioContext.createBufferSource();
                    this.sourceNode.buffer = audioBuffer;
                    this.sourceNode.loop = true;  // Loop continuously
                    this.sourceNode.connect(this.audioContext.destination);
                    
                    // Handle end (shouldn't happen with loop=true, but just in case)
                    this.sourceNode.onended = () => {
                        if (this.isTransmitting) {
                            // Restart if still transmitting
                            this.playCalibrationSequence();
                        }
                    };
                    
                    // Start playback
                    this.sourceNode.start(0);
                    
                } catch (error) {
                    console.error('Error playing calibration sequence:', error);
                    this.isTransmitting = false;
                }
            }

            /**
             * Generate the complete calibration sequence audio buffer
             * @returns {AudioBuffer} The calibration sequence
             */
            generateCalibrationSequence() {
                // Sequence: Preamble -> Silence -> Bit0 -> Silence -> Bit1 -> Silence
                const preambleTone = this.generateTone(this.freqPreamble, this.toneDuration);
                const bit0Tone = this.generateTone(this.freq0, this.toneDuration);
                const bit1Tone = this.generateTone(this.freq1, this.toneDuration);
                const silence = this.generateSilence(this.silenceDuration);
                
                // Calculate total length
                const totalLength = preambleTone.length + silence.length +
                                  bit0Tone.length + silence.length +
                                  bit1Tone.length + silence.length;
                
                // Create audio buffer
                const audioBuffer = this.audioContext.createBuffer(1, totalLength, this.sampleRate);
                const channelData = audioBuffer.getChannelData(0);
                
                // Assemble sequence
                let offset = 0;
                
                // Preamble tone
                channelData.set(preambleTone, offset);
                offset += preambleTone.length;
                
                // Silence
                channelData.set(silence, offset);
                offset += silence.length;
                
                // Bit 0 tone
                channelData.set(bit0Tone, offset);
                offset += bit0Tone.length;
                
                // Silence
                channelData.set(silence, offset);
                offset += silence.length;
                
                // Bit 1 tone
                channelData.set(bit1Tone, offset);
                offset += bit1Tone.length;
                
                // Silence
                channelData.set(silence, offset);
                
                return audioBuffer;
            }

            /**
             * Generate a tone at a specific frequency
             * @param {number} frequency - Frequency in Hz
             * @param {number} duration - Duration in seconds
             * @returns {Float32Array} Audio samples
             */
            generateTone(frequency, duration) {
                const samples = Math.floor(this.sampleRate * duration);
                const tone = new Float32Array(samples);
                
                for (let i = 0; i < samples; i++) {
                    const t = i / this.sampleRate;
                    tone[i] = Math.sin(2 * Math.PI * frequency * t) * 0.5;
                }
                
                return tone;
            }

            /**
             * Generate silence
             * @param {number} duration - Duration in seconds
             * @returns {Float32Array} Silent audio samples
             */
            generateSilence(duration) {
                const samples = Math.floor(this.sampleRate * duration);
                return new Float32Array(samples);  // All zeros
            }

            /**
             * Check if currently transmitting
             * @returns {boolean} True if transmitting
             */
            isTransmittingCalibration() {
                return this.isTransmitting;
            }
        }

        // SpectrumAnalyzer class - Performs FFT analysis on audio input
        class SpectrumAnalyzer {
            constructor(audioContext, fftSize = 8192) {
                this.audioContext = audioContext;
                this.fftSize = fftSize;
                this.analyser = null;
                this.frequencyData = null;
                this.isConnected = false;
            }

            /**
             * Connect to an audio source node
             * @param {AudioNode} sourceNode - The audio source to analyze
             */
            connect(sourceNode) {
                if (this.isConnected) {
                    this.disconnect();
                }
                
                // Create analyser node
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = this.fftSize;
                this.analyser.smoothingTimeConstant = 0.8;
                
                // Allocate frequency data array
                this.frequencyData = new Float32Array(this.analyser.frequencyBinCount);
                
                // Connect source to analyser
                sourceNode.connect(this.analyser);
                
                this.isConnected = true;
            }

            /**
             * Disconnect from audio source
             */
            disconnect() {
                if (this.analyser) {
                    this.analyser.disconnect();
                    this.analyser = null;
                }
                this.isConnected = false;
                this.frequencyData = null;
            }

            /**
             * Get current frequency data
             * @returns {Float32Array} Frequency data in dB
             */
            getFrequencyData() {
                if (!this.analyser || !this.frequencyData) {
                    return new Float32Array(0);
                }
                
                this.analyser.getFloatFrequencyData(this.frequencyData);
                return this.frequencyData;
            }

            /**
             * Get frequency bins for a specific range
             * @param {number} minFreq - Minimum frequency (Hz)
             * @param {number} maxFreq - Maximum frequency (Hz)
             * @returns {Float32Array} Frequency data for the range
             */
            getFrequencyRange(minFreq, maxFreq) {
                const fullData = this.getFrequencyData();
                
                const minIndex = this.frequencyToIndex(minFreq);
                const maxIndex = this.frequencyToIndex(maxFreq);
                
                return fullData.slice(minIndex, maxIndex + 1);
            }

            /**
             * Convert frequency to FFT bin index
             * @param {number} frequency - Frequency in Hz
             * @returns {number} Bin index
             */
            frequencyToIndex(frequency) {
                const nyquist = this.audioContext.sampleRate / 2;
                const index = Math.round((frequency / nyquist) * this.analyser.frequencyBinCount);
                return Math.max(0, Math.min(index, this.analyser.frequencyBinCount - 1));
            }

            /**
             * Convert FFT bin index to frequency
             * @param {number} index - Bin index
             * @returns {number} Frequency in Hz
             */
            indexToFrequency(index) {
                const nyquist = this.audioContext.sampleRate / 2;
                return (index / this.analyser.frequencyBinCount) * nyquist;
            }

            /**
             * Get all frequency bins
             * @returns {Array<number>} Array of bin indices
             */
            getFrequencyBins() {
                if (!this.analyser) {
                    return [];
                }
                
                const bins = [];
                for (let i = 0; i < this.analyser.frequencyBinCount; i++) {
                    bins.push(i);
                }
                return bins;
            }

            /**
             * Check if connected
             * @returns {boolean} True if connected to audio source
             */
            isAnalyzerConnected() {
                return this.isConnected;
            }
        }

        // SyncFrequencyDetector class - Detects calibration frequencies from spectrum
        class SyncFrequencyDetector {
            constructor() {
                this.magnitudeThreshold = -40;  // dB
                this.minSeparation = 500;  // Hz
            }

            /**
             * Detect peaks in spectrum data
             * @param {Float32Array} spectrumData - Frequency spectrum in dB
             * @param {number} minFreq - Minimum frequency to consider (Hz)
             * @param {number} maxFreq - Maximum frequency to consider (Hz)
             * @param {SpectrumAnalyzer} analyzer - Spectrum analyzer for frequency conversion
             * @returns {Array<Object>} Array of peaks {frequency, magnitude, index}
             */
            detectPeaks(spectrumData, minFreq, maxFreq, analyzer) {
                const peaks = [];
                
                const minIndex = analyzer.frequencyToIndex(minFreq);
                const maxIndex = analyzer.frequencyToIndex(maxFreq);
                
                // Find local maxima
                for (let i = minIndex + 1; i < maxIndex - 1; i++) {
                    const current = spectrumData[i];
                    const prev = spectrumData[i - 1];
                    const next = spectrumData[i + 1];
                    
                    // Check if local maximum and above threshold
                    if (current > prev && current > next && current > this.magnitudeThreshold) {
                        peaks.push({
                            frequency: analyzer.indexToFrequency(i),
                            magnitude: current,
                            index: i
                        });
                    }
                }
                
                // Sort by magnitude (strongest first)
                peaks.sort((a, b) => b.magnitude - a.magnitude);
                
                return peaks;
            }

            /**
             * Identify calibration frequencies from peaks
             * @param {Array<Object>} peaks - Array of detected peaks
             * @returns {Object|null} Detected frequencies or null
             */
            identifyCalibrationFrequencies(peaks) {
                if (peaks.length < 3) {
                    return null;
                }
                
                // Take top 3 peaks
                const top3 = peaks.slice(0, 3);
                
                // Validate frequency separation
                if (!this.validateFrequencies(top3)) {
                    return null;
                }
                
                // Sort by frequency (ascending)
                top3.sort((a, b) => a.frequency - b.frequency);
                
                // Classify: lowest = bit0, middle = preamble, highest = bit1
                const result = {
                    bit0: Math.round(top3[0].frequency),
                    preamble: Math.round(top3[1].frequency),
                    bit1: Math.round(top3[2].frequency),
                    confidence: this.calculateConfidence(top3)
                };
                
                return result;
            }

            /**
             * Validate that frequencies are sufficiently separated
             * @param {Array<Object>} peaks - Array of peaks to validate
             * @returns {boolean} True if valid
             */
            validateFrequencies(peaks) {
                // Check all pairs for minimum separation
                for (let i = 0; i < peaks.length; i++) {
                    for (let j = i + 1; j < peaks.length; j++) {
                        const separation = Math.abs(peaks[i].frequency - peaks[j].frequency);
                        if (separation < this.minSeparation) {
                            return false;
                        }
                    }
                }
                return true;
            }

            /**
             * Calculate confidence score for detected frequencies
             * @param {Array<Object>} peaks - Array of detected peaks
             * @returns {number} Confidence score (0-1)
             */
            calculateConfidence(peaks) {
                if (peaks.length < 3) {
                    return 0;
                }
                
                // Calculate average magnitude
                const avgMagnitude = peaks.reduce((sum, p) => sum + p.magnitude, 0) / peaks.length;
                
                // Estimate noise floor (assume -60 dB)
                const noiseFloor = -60;
                
                // Peak strength component (0-1)
                const peakStrength = Math.min(1, (avgMagnitude - noiseFloor) / 40);
                
                // Separation component (0-1)
                const separations = [];
                for (let i = 0; i < peaks.length; i++) {
                    for (let j = i + 1; j < peaks.length; j++) {
                        separations.push(Math.abs(peaks[i].frequency - peaks[j].frequency));
                    }
                }
                const minSep = Math.min(...separations);
                const separationScore = Math.min(1, minSep / this.minSeparation);
                
                // Weighted combination
                const confidence = (peakStrength * 0.6) + (separationScore * 0.4);
                
                return confidence;
            }

            /**
             * Estimate noise floor from spectrum data
             * @param {Float32Array} spectrumData - Frequency spectrum in dB
             * @returns {number} Estimated noise floor in dB
             */
            estimateNoiseFloor(spectrumData) {
                // Sort magnitudes and take median of lower half
                const sorted = Array.from(spectrumData).sort((a, b) => a - b);
                const lowerHalf = sorted.slice(0, Math.floor(sorted.length / 2));
                const median = lowerHalf[Math.floor(lowerHalf.length / 2)];
                return median;
            }
        }

        // DecoderConfigurator class - Updates decoder with detected frequencies
        class DecoderConfigurator {
            constructor() {
                this.activeFrequencies = {
                    preamble: 5500,
                    bit0: 4500,
                    bit1: 6500,
                    source: 'default'
                };
                this.storageKey = 'audioTransfer_syncFrequencies';
            }

            /**
             * Update AudioDecoder with detected frequencies
             * @param {AudioDecoder} decoder - The decoder to update
             * @param {Object} frequencies - Detected frequencies {preamble, bit0, bit1}
             */
            updateFrequencies(decoder, frequencies) {
                // Update decoder's frequency detector
                if (decoder && decoder.frequencyDetector) {
                    decoder.frequencyDetector.freq0 = frequencies.bit0;
                    decoder.frequencyDetector.freq1 = frequencies.bit1;
                    decoder.frequencyDetector.freqPreamble = frequencies.preamble;
                    
                    // Recreate Goertzel filters with new frequencies
                    const sampleRate = decoder.frequencyDetector.sampleRate;
                    const windowSize = decoder.frequencyDetector.windowSize;
                    
                    decoder.frequencyDetector.filter0 = new GoertzelFilter(
                        frequencies.bit0, sampleRate, windowSize
                    );
                    decoder.frequencyDetector.filter1 = new GoertzelFilter(
                        frequencies.bit1, sampleRate, windowSize
                    );
                    decoder.frequencyDetector.filterPreamble = new GoertzelFilter(
                        frequencies.preamble, sampleRate, windowSize
                    );
                }
                
                // Update active frequencies
                this.activeFrequencies = {
                    preamble: frequencies.preamble,
                    bit0: frequencies.bit0,
                    bit1: frequencies.bit1,
                    source: 'detected'
                };
                
                // Persist to session storage
                this.persistFrequencies(frequencies);
            }

            /**
             * Persist frequencies to session storage
             * @param {Object} frequencies - Frequencies to persist
             */
            persistFrequencies(frequencies) {
                try {
                    const data = {
                        preamble: frequencies.preamble,
                        bit0: frequencies.bit0,
                        bit1: frequencies.bit1,
                        timestamp: Date.now()
                    };
                    sessionStorage.setItem(this.storageKey, JSON.stringify(data));
                } catch (e) {
                    console.error('Failed to persist frequencies:', e);
                }
            }

            /**
             * Load persisted frequencies from session storage
             * @returns {Object|null} Persisted frequencies or null
             */
            loadPersistedFrequencies() {
                try {
                    const data = sessionStorage.getItem(this.storageKey);
                    if (data) {
                        return JSON.parse(data);
                    }
                } catch (e) {
                    console.error('Failed to load persisted frequencies:', e);
                }
                return null;
            }

            /**
             * Reset to default frequencies
             */
            resetToDefaults() {
                this.activeFrequencies = {
                    preamble: 5500,
                    bit0: 4500,
                    bit1: 6500,
                    source: 'default'
                };
                
                // Clear session storage
                try {
                    sessionStorage.removeItem(this.storageKey);
                } catch (e) {
                    console.error('Failed to clear persisted frequencies:', e);
                }
            }

            /**
             * Get currently active frequencies
             * @returns {Object} Active frequencies
             */
            getActiveFrequencies() {
                return this.activeFrequencies;
            }
        }

        // SyncUIManager class - Manages sync-related UI elements
        class SyncUIManager {
            constructor(mode) {
                this.mode = mode;  // 'emitter' or 'receiver'
                
                // Get UI elements
                this.syncBtn = document.getElementById(`${mode}SyncBtn`);
                this.syncStatus = document.getElementById(`${mode}SyncStatus`);
                
                if (mode === 'receiver') {
                    this.spectrumCanvas = document.getElementById('spectrumCanvas');
                    this.spectrumCtx = this.spectrumCanvas ? this.spectrumCanvas.getContext('2d') : null;
                    this.frequencyDisplay = document.getElementById('frequencyDisplay');
                    this.freq0Value = document.getElementById('freq0Value');
                    this.freqPreambleValue = document.getElementById('freqPreambleValue');
                    this.freq1Value = document.getElementById('freq1Value');
                }
            }

            /**
             * Show sync button
             */
            showSyncButton() {
                if (this.syncBtn) {
                    this.syncBtn.style.display = 'block';
                }
            }

            /**
             * Hide sync button
             */
            hideSyncButton() {
                if (this.syncBtn) {
                    this.syncBtn.style.display = 'none';
                }
            }

            /**
             * Update sync button state based on sync state
             * @param {string} state - Sync state (idle, transmitting, listening, detected, error)
             */
            updateSyncButtonState(state) {
                if (!this.syncBtn) return;
                
                switch (state) {
                    case 'idle':
                        this.syncBtn.textContent = this.mode === 'emitter' ? 
                            'Start Sync Transmission' : 'Start Sync Listening';
                        this.syncBtn.classList.remove('active');
                        this.syncBtn.disabled = false;
                        break;
                    
                    case 'transmitting':
                        this.syncBtn.textContent = 'Stop Sync Transmission';
                        this.syncBtn.classList.add('active');
                        this.syncBtn.disabled = false;
                        break;
                    
                    case 'listening':
                        this.syncBtn.textContent = 'Stop Sync Listening';
                        this.syncBtn.classList.add('active');
                        this.syncBtn.disabled = false;
                        break;
                    
                    case 'detected':
                        this.syncBtn.textContent = 'Start Sync Listening';
                        this.syncBtn.classList.remove('active');
                        this.syncBtn.disabled = false;
                        break;
                    
                    case 'error':
                        this.syncBtn.textContent = this.mode === 'emitter' ? 
                            'Start Sync Transmission' : 'Start Sync Listening';
                        this.syncBtn.classList.remove('active');
                        this.syncBtn.disabled = false;
                        break;
                }
            }

            /**
             * Display frequency spectrum visualization
             * @param {Float32Array} spectrumData - Frequency spectrum data
             * @param {SpectrumAnalyzer} analyzer - Spectrum analyzer for frequency mapping
             */
            displayFrequencySpectrum(spectrumData, analyzer) {
                if (!this.spectrumCanvas || !this.spectrumCtx || this.mode !== 'receiver') {
                    return;
                }
                
                // Show canvas
                this.spectrumCanvas.classList.add('active');
                
                const width = this.spectrumCanvas.width;
                const height = this.spectrumCanvas.height;
                const ctx = this.spectrumCtx;
                
                // Clear canvas
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, width, height);
                
                // Draw spectrum (4-8 kHz range)
                const minFreq = 4000;
                const maxFreq = 8000;
                const minIndex = analyzer.frequencyToIndex(minFreq);
                const maxIndex = analyzer.frequencyToIndex(maxFreq);
                const rangeData = spectrumData.slice(minIndex, maxIndex + 1);
                
                // Normalize data for display
                const minDb = -80;
                const maxDb = -20;
                
                ctx.beginPath();
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                
                for (let i = 0; i < rangeData.length; i++) {
                    const x = (i / rangeData.length) * width;
                    const normalized = (rangeData[i] - minDb) / (maxDb - minDb);
                    const y = height - (Math.max(0, Math.min(1, normalized)) * height);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
                
                // Draw frequency labels
                ctx.fillStyle = '#999';
                ctx.font = '10px monospace';
                ctx.fillText('4kHz', 5, height - 5);
                ctx.fillText('6kHz', width / 2 - 15, height - 5);
                ctx.fillText('8kHz', width - 35, height - 5);
            }

            /**
             * Highlight detected peaks in visualization
             * @param {Array<Object>} peaks - Array of peaks {frequency, magnitude}
             * @param {SpectrumAnalyzer} analyzer - Spectrum analyzer
             */
            highlightDetectedPeaks(peaks, analyzer) {
                if (!this.spectrumCanvas || !this.spectrumCtx || this.mode !== 'receiver') {
                    return;
                }
                
                const width = this.spectrumCanvas.width;
                const height = this.spectrumCanvas.height;
                const ctx = this.spectrumCtx;
                
                const minFreq = 4000;
                const maxFreq = 8000;
                
                // Draw peak markers
                ctx.fillStyle = '#10b981';
                peaks.forEach(peak => {
                    if (peak.frequency >= minFreq && peak.frequency <= maxFreq) {
                        const x = ((peak.frequency - minFreq) / (maxFreq - minFreq)) * width;
                        
                        // Draw vertical line
                        ctx.beginPath();
                        ctx.strokeStyle = '#10b981';
                        ctx.lineWidth = 2;
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, height);
                        ctx.stroke();
                        
                        // Draw frequency label
                        ctx.fillStyle = '#10b981';
                        ctx.font = 'bold 11px monospace';
                        ctx.fillText(Math.round(peak.frequency) + 'Hz', x + 3, 15);
                    }
                });
            }

            /**
             * Display detected frequency values
             * @param {Object} frequencies - Detected frequencies {preamble, bit0, bit1}
             */
            displayDetectedFrequencies(frequencies) {
                if (this.mode !== 'receiver') return;
                
                // Show frequency display
                if (this.frequencyDisplay) {
                    this.frequencyDisplay.classList.add('active');
                }
                
                // Update values
                if (this.freq0Value) {
                    this.freq0Value.textContent = frequencies.bit0;
                }
                if (this.freqPreambleValue) {
                    this.freqPreambleValue.textContent = frequencies.preamble;
                }
                if (this.freq1Value) {
                    this.freq1Value.textContent = frequencies.bit1;
                }
            }

            /**
             * Show sync error message
             * @param {Object} error - Error object {type, message, suggestions}
             */
            showSyncError(error) {
                if (!this.syncStatus) return;
                
                this.syncStatus.textContent = 'âŒ ' + error.message;
                this.syncStatus.className = 'sync-status error active';
            }

            /**
             * Show sync success message
             */
            showSyncSuccess() {
                if (!this.syncStatus) return;
                
                this.syncStatus.textContent = 'âœ“ Frequencies detected successfully!';
                this.syncStatus.className = 'sync-status detected active';
            }

            /**
             * Show low signal warning
             */
            showLowSignalWarning() {
                if (!this.syncStatus) return;
                
                this.syncStatus.textContent = 'âš  Low signal level. Please increase volume or move devices closer.';
                this.syncStatus.className = 'sync-status error active';
            }

            /**
             * Update sync status display
             * @param {string} state - Sync state
             * @param {string} message - Status message
             */
            updateSyncStatus(state, message) {
                if (!this.syncStatus) return;
                
                this.syncStatus.textContent = message;
                this.syncStatus.className = `sync-status ${state} active`;
            }

            /**
             * Hide sync status
             */
            hideSyncStatus() {
                if (this.syncStatus) {
                    this.syncStatus.classList.remove('active');
                }
            }
        }

        // DataProcessor class
        class DataProcessor {
            constructor() {
                this.chunkSize = 255; // Maximum chunk size in bytes
            }

            /**
             * Prepare text data for transmission
             * @param {string} text - The text to prepare
             * @returns {Object} PreparedData object
             */
            prepareText(text) {
                const encoder = new TextEncoder();
                const data = encoder.encode(text);
                const checksum = this.calculateChecksum(data);
                
                return {
                    type: 'text',
                    filename: null,
                    data: data,
                    checksum: checksum
                };
            }

            /**
             * Prepare file data for transmission
             * @param {File} file - The file to prepare
             * @returns {Promise<Object>} Promise resolving to PreparedData object
             */
            async prepareFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    
                    reader.onload = (event) => {
                        const arrayBuffer = event.target.result;
                        const data = new Uint8Array(arrayBuffer);
                        const checksum = this.calculateChecksum(data);
                        
                        resolve({
                            type: 'file',
                            filename: file.name,
                            data: data,
                            checksum: checksum
                        });
                    };
                    
                    reader.onerror = () => {
                        reject(new Error('Failed to read file'));
                    };
                    
                    reader.readAsArrayBuffer(file);
                });
            }

            /**
             * Split data into chunks
             * @param {Uint8Array} data - The data to chunk
             * @param {number} chunkSize - Size of each chunk (default: 255)
             * @returns {Array} Array of Chunk objects
             */
            chunkData(data, chunkSize = this.chunkSize) {
                const chunks = [];
                const totalChunks = Math.ceil(data.length / chunkSize);
                
                for (let i = 0; i < totalChunks; i++) {
                    const start = i * chunkSize;
                    const end = Math.min(start + chunkSize, data.length);
                    const chunkData = data.slice(start, end);
                    
                    chunks.push({
                        index: i,
                        total: totalChunks,
                        data: chunkData,
                        checksum: this.calculateChecksum(chunkData)
                    });
                }
                
                return chunks;
            }

            /**
             * Reconstruct data from chunks
             * @param {Array} chunks - Array of Chunk objects
             * @returns {Uint8Array} Reconstructed data
             */
            reconstructData(chunks) {
                // Sort chunks by index to ensure correct order
                const sortedChunks = chunks.slice().sort((a, b) => a.index - b.index);
                
                // Calculate total size
                let totalSize = 0;
                for (const chunk of sortedChunks) {
                    totalSize += chunk.data.length;
                }
                
                // Create result array
                const result = new Uint8Array(totalSize);
                
                // Copy chunk data into result
                let offset = 0;
                for (const chunk of sortedChunks) {
                    result.set(chunk.data, offset);
                    offset += chunk.data.length;
                }
                
                return result;
            }

            /**
             * Calculate CRC16 checksum for data
             * @param {Uint8Array} data - The data to checksum
             * @returns {number} 16-bit checksum value
             */
            calculateChecksum(data) {
                // CRC16-CCITT polynomial: 0x1021
                const polynomial = 0x1021;
                let crc = 0xFFFF;
                
                for (let i = 0; i < data.length; i++) {
                    crc ^= (data[i] << 8);
                    
                    for (let j = 0; j < 8; j++) {
                        if (crc & 0x8000) {
                            crc = (crc << 1) ^ polynomial;
                        } else {
                            crc = crc << 1;
                        }
                    }
                }
                
                return crc & 0xFFFF;
            }

            /**
             * Verify checksum of data
             * @param {Uint8Array} data - The data to verify
             * @param {number} expectedChecksum - The expected checksum value
             * @returns {boolean} True if checksum matches
             */
            verifyChecksum(data, expectedChecksum) {
                const actualChecksum = this.calculateChecksum(data);
                return actualChecksum === expectedChecksum;
            }
        }

        // Input Handler class
        class InputHandler {
            constructor(dataProcessor) {
                this.dataProcessor = dataProcessor;
                this.currentInput = null; // Stores the most recent prepared data
                this.lastInputType = null; // 'text' or 'file'
                this.sendButton = document.getElementById('sendBtn');
                this.textInput = document.getElementById('textInput');
                this.fileInput = document.getElementById('fileInput');
                this.statusElement = document.getElementById('emitterStatus');
                
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                // Text input event listener
                this.textInput.addEventListener('input', () => {
                    this.handleTextInput();
                });

                // File input event listener
                this.fileInput.addEventListener('change', () => {
                    this.handleFileInput();
                });
            }

            /**
             * Handle text input changes
             */
            handleTextInput() {
                const text = this.textInput.value.trim();
                
                if (text.length > 0) {
                    // Prepare text data
                    this.currentInput = this.dataProcessor.prepareText(text);
                    this.lastInputType = 'text';
                    
                    // Clear file input to show text has priority
                    this.fileInput.value = '';
                    
                    // Update send button state
                    this.updateSendButtonState();
                    
                    // Clear any previous warnings
                    this.hideStatus();
                } else {
                    // No valid text input
                    this.currentInput = null;
                    this.lastInputType = null;
                    this.updateSendButtonState();
                }
            }

            /**
             * Handle file input changes
             */
            async handleFileInput() {
                const file = this.fileInput.files[0];
                
                if (file) {
                    // Check file size and warn if > 1MB
                    const fileSizeMB = file.size / (1024 * 1024);
                    
                    if (fileSizeMB > 1) {
                        // Calculate estimated transmission time
                        // At 100 baud with 11 bits per byte = 9.09 bytes/second
                        const estimatedSeconds = file.size / 9.09;
                        const estimatedMinutes = Math.ceil(estimatedSeconds / 60);
                        
                        this.showWarning(
                            `Warning: File size is ${fileSizeMB.toFixed(2)} MB. ` +
                            `Estimated transmission time: ~${estimatedMinutes} minutes.`
                        );
                    } else {
                        this.hideStatus();
                    }
                    
                    try {
                        // Prepare file data
                        this.currentInput = await this.dataProcessor.prepareFile(file);
                        this.lastInputType = 'file';
                        
                        // Clear text input to show file has priority
                        this.textInput.value = '';
                        
                        // Update send button state
                        this.updateSendButtonState();
                    } catch (error) {
                        this.showError('Failed to read file: ' + error.message);
                        this.currentInput = null;
                        this.lastInputType = null;
                        this.updateSendButtonState();
                    }
                } else {
                    // No file selected
                    this.currentInput = null;
                    this.lastInputType = null;
                    this.updateSendButtonState();
                    this.hideStatus();
                }
            }

            /**
             * Update send button enabled/disabled state based on data validity
             */
            updateSendButtonState() {
                if (this.currentInput && this.currentInput.data && this.currentInput.data.length > 0) {
                    this.sendButton.disabled = false;
                } else {
                    this.sendButton.disabled = true;
                }
            }

            /**
             * Get the current prepared input data
             * @returns {Object|null} PreparedData object or null
             */
            getCurrentInput() {
                return this.currentInput;
            }

            /**
             * Clear all inputs
             */
            clearInputs() {
                this.textInput.value = '';
                this.fileInput.value = '';
                this.currentInput = null;
                this.lastInputType = null;
                this.updateSendButtonState();
                this.hideStatus();
            }

            /**
             * Show warning message
             * @param {string} message - Warning message to display
             */
            showWarning(message) {
                this.statusElement.textContent = message;
                this.statusElement.className = 'status-message warning active';
            }

            /**
             * Show error message
             * @param {string} message - Error message to display
             */
            showError(message) {
                this.statusElement.textContent = message;
                this.statusElement.className = 'status-message error active';
            }

            /**
             * Hide status message
             */
            hideStatus() {
                this.statusElement.className = 'status-message';
                this.statusElement.textContent = '';
            }
        }

        // AudioEncoder class
        class AudioEncoder {
            constructor() {
                this.sampleRate = 48000; // Standard sample rate
                this.freq0 = 4500; // Frequency for bit 0
                this.freq1 = 6500; // Frequency for bit 1
                this.freqPreamble = 5500; // Preamble frequency
                this.baudRate = 100; // Bits per second
                this.bitDuration = this.sampleRate / this.baudRate; // Samples per bit
            }

            /**
             * Main encode function - assembles complete transmission
             * @param {Object} preparedData - PreparedData object from DataProcessor
             * @returns {AudioBuffer} Complete encoded audio transmission
             */
            encode(preparedData) {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Chunk the data
                const dataProcessor = new DataProcessor();
                const chunks = dataProcessor.chunkData(preparedData.data);
                
                // Generate all parts
                const preamble = this.generatePreamble();
                const header = this.encodeHeader(preparedData, chunks.length);
                const encodedChunks = chunks.map(chunk => this.encodeChunk(chunk));
                const postamble = this.generatePostamble();
                
                // Calculate total length
                let totalLength = preamble.length + header.length + postamble.length;
                for (const encodedChunk of encodedChunks) {
                    totalLength += encodedChunk.length;
                }
                
                // Create audio buffer
                const audioBuffer = audioContext.createBuffer(1, totalLength, this.sampleRate);
                const channelData = audioBuffer.getChannelData(0);
                
                // Assemble transmission
                let offset = 0;
                
                // Add preamble
                channelData.set(preamble, offset);
                offset += preamble.length;
                
                // Add header
                channelData.set(header, offset);
                offset += header.length;
                
                // Add chunks
                for (const encodedChunk of encodedChunks) {
                    channelData.set(encodedChunk, offset);
                    offset += encodedChunk.length;
                }
                
                // Add postamble
                channelData.set(postamble, offset);
                
                return audioBuffer;
            }

            /**
             * Generate preamble - 5000ms synchronization tone at 5500 Hz
             * @returns {Float32Array} Preamble audio samples
             */
            generatePreamble() {
                const duration = 5.0; // 5000ms (5 seconds)
                const samples = Math.floor(this.sampleRate * duration);
                const preamble = new Float32Array(samples);
                
                for (let i = 0; i < samples; i++) {
                    const t = i / this.sampleRate;
                    preamble[i] = Math.sin(2 * Math.PI * this.freqPreamble * t) * 0.5;
                }
                
                return preamble;
            }

            /**
             * Generate postamble - 2000ms silence
             * @returns {Float32Array} Postamble audio samples (silence)
             */
            generatePostamble() {
                const duration = 2.0; // 2000ms (2 seconds)
                const samples = Math.floor(this.sampleRate * duration);
                return new Float32Array(samples); // All zeros = silence
            }

            /**
             * Encode header with metadata
             * @param {Object} preparedData - PreparedData object
             * @param {number} totalChunks - Total number of chunks
             * @returns {Float32Array} Encoded header audio samples
             */
            encodeHeader(preparedData, totalChunks) {
                // Build header bytes
                const headerBytes = [];
                
                // Magic bytes (2 bytes): 0xAA 0x55
                headerBytes.push(0xAA, 0x55);
                
                // Data type (1 byte): 0x01=text, 0x02=file
                headerBytes.push(preparedData.type === 'text' ? 0x01 : 0x02);
                
                // Filename handling
                let filenameBytes = [];
                if (preparedData.filename) {
                    const encoder = new TextEncoder();
                    filenameBytes = Array.from(encoder.encode(preparedData.filename));
                }
                
                // Filename length (1 byte)
                headerBytes.push(filenameBytes.length);
                
                // Filename (variable length, UTF-8)
                headerBytes.push(...filenameBytes);
                
                // Total chunks (2 bytes, big-endian)
                headerBytes.push((totalChunks >> 8) & 0xFF);
                headerBytes.push(totalChunks & 0xFF);
                
                // Total data size (4 bytes, big-endian)
                const dataSize = preparedData.data.length;
                headerBytes.push((dataSize >> 24) & 0xFF);
                headerBytes.push((dataSize >> 16) & 0xFF);
                headerBytes.push((dataSize >> 8) & 0xFF);
                headerBytes.push(dataSize & 0xFF);
                
                // Header checksum (2 bytes)
                const dataProcessor = new DataProcessor();
                const headerChecksum = dataProcessor.calculateChecksum(new Uint8Array(headerBytes));
                headerBytes.push((headerChecksum >> 8) & 0xFF);
                headerBytes.push(headerChecksum & 0xFF);
                
                // Encode header bytes to audio
                return this.encodeBytes(new Uint8Array(headerBytes));
            }

            /**
             * Encode a single chunk with start/stop bits and parity
             * @param {Object} chunk - Chunk object with index, total, data, checksum
             * @returns {Float32Array} Encoded chunk audio samples
             */
            encodeChunk(chunk) {
                const chunkBytes = [];
                
                // Chunk index (2 bytes, big-endian)
                chunkBytes.push((chunk.index >> 8) & 0xFF);
                chunkBytes.push(chunk.index & 0xFF);
                
                // Data length (1 byte)
                chunkBytes.push(chunk.data.length);
                
                // Data (variable length)
                chunkBytes.push(...Array.from(chunk.data));
                
                // Chunk checksum (2 bytes)
                chunkBytes.push((chunk.checksum >> 8) & 0xFF);
                chunkBytes.push(chunk.checksum & 0xFF);
                
                // Encode chunk bytes to audio
                return this.encodeBytes(new Uint8Array(chunkBytes));
            }

            /**
             * Encode bytes to audio with start/stop bits and parity
             * @param {Uint8Array} bytes - Bytes to encode
             * @returns {Float32Array} Encoded audio samples
             */
            encodeBytes(bytes) {
                const encodedBits = [];
                
                // Encode each byte with framing
                for (let i = 0; i < bytes.length; i++) {
                    const byte = bytes[i];
                    
                    // Start bit (0)
                    encodedBits.push(0);
                    
                    // 8 data bits (LSB first)
                    let onesCount = 0;
                    for (let bit = 0; bit < 8; bit++) {
                        const bitValue = (byte >> bit) & 1;
                        encodedBits.push(bitValue);
                        if (bitValue === 1) onesCount++;
                    }
                    
                    // Parity bit (even parity)
                    const parityBit = onesCount % 2;
                    encodedBits.push(parityBit);
                    
                    // Stop bit (1)
                    encodedBits.push(1);
                }
                
                // Convert bits to FSK audio
                return this.encodeBitsToFSK(encodedBits);
            }

            /**
             * Encode bits to FSK audio signal
             * @param {Array} bits - Array of bit values (0 or 1)
             * @returns {Float32Array} FSK-encoded audio samples
             */
            encodeBitsToFSK(bits) {
                const totalSamples = bits.length * this.bitDuration;
                const audio = new Float32Array(totalSamples);
                
                for (let i = 0; i < bits.length; i++) {
                    const bit = bits[i];
                    const frequency = bit === 0 ? this.freq0 : this.freq1;
                    const startSample = i * this.bitDuration;
                    
                    // Generate tone for this bit
                    for (let j = 0; j < this.bitDuration; j++) {
                        const sampleIndex = startSample + j;
                        const t = sampleIndex / this.sampleRate;
                        audio[sampleIndex] = Math.sin(2 * Math.PI * frequency * t) * 0.5;
                    }
                }
                
                return audio;
            }
        }

        // AudioPlayer class
        class AudioPlayer {
            constructor() {
                this.audioContext = null;
                this.sourceNode = null;
                this.isPlaying = false;
                this.startTime = 0;
                this.pauseTime = 0;
                this.duration = 0;
                this.progressCallbacks = [];
                this.progressInterval = null;
            }

            /**
             * Play an audio buffer through speakers
             * @param {AudioBuffer} audioBuffer - The audio buffer to play
             * @returns {Promise<void>} Promise that resolves when playback completes
             */
            async play(audioBuffer) {
                // Stop any existing playback
                this.stop();

                // Create audio context if needed
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                // Resume audio context if suspended (required by some browsers)
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }

                return new Promise((resolve, reject) => {
                    try {
                        // Create source node
                        this.sourceNode = this.audioContext.createBufferSource();
                        this.sourceNode.buffer = audioBuffer;
                        this.sourceNode.connect(this.audioContext.destination);

                        // Store duration
                        this.duration = audioBuffer.duration;

                        // Set up completion handler
                        this.sourceNode.onended = () => {
                            this.isPlaying = false;
                            this.stopProgressTracking();
                            // Notify 100% progress on completion
                            this.notifyProgress(1.0);
                            resolve();
                        };

                        // Start playback
                        this.startTime = this.audioContext.currentTime;
                        this.sourceNode.start(0);
                        this.isPlaying = true;

                        // Start progress tracking
                        this.startProgressTracking();
                        
                        // Notify that playback has started (for visualization setup)
                        // Small delay to ensure source node is fully initialized
                        setTimeout(() => {
                            if (this.onPlaybackStartCallback) {
                                this.onPlaybackStartCallback();
                            }
                        }, 10);

                    } catch (error) {
                        reject(error);
                    }
                });
            }

            /**
             * Stop playback
             */
            stop() {
                if (this.sourceNode && this.isPlaying) {
                    try {
                        this.sourceNode.stop();
                    } catch (e) {
                        // Ignore errors if already stopped
                    }
                    this.sourceNode.disconnect();
                    this.sourceNode = null;
                }

                this.isPlaying = false;
                this.stopProgressTracking();
            }

            /**
             * Get current playback progress (0.0 to 1.0)
             * @returns {number} Progress value between 0 and 1
             */
            getProgress() {
                if (!this.isPlaying || !this.audioContext || this.duration === 0) {
                    return 0;
                }

                const elapsed = this.audioContext.currentTime - this.startTime;
                const progress = Math.min(elapsed / this.duration, 1.0);
                return progress;
            }

            /**
             * Register a callback for progress updates
             * @param {Function} callback - Callback function that receives progress (0.0 to 1.0)
             */
            onProgressUpdate(callback) {
                if (typeof callback === 'function') {
                    this.progressCallbacks.push(callback);
                }
            }

            /**
             * Clear all progress callbacks
             */
            clearProgressCallbacks() {
                this.progressCallbacks = [];
            }

            /**
             * Register a callback for when playback starts
             * @param {Function} callback - Callback function
             */
            onPlaybackStart(callback) {
                if (typeof callback === 'function') {
                    this.onPlaybackStartCallback = callback;
                }
            }

            /**
             * Start tracking progress and calling callbacks
             * @private
             */
            startProgressTracking() {
                // Update progress every 100ms
                this.progressInterval = setInterval(() => {
                    if (this.isPlaying) {
                        const progress = this.getProgress();
                        this.notifyProgress(progress);
                    }
                }, 100);
            }

            /**
             * Stop tracking progress
             * @private
             */
            stopProgressTracking() {
                if (this.progressInterval) {
                    clearInterval(this.progressInterval);
                    this.progressInterval = null;
                }
            }

            /**
             * Notify all registered callbacks of progress update
             * @param {number} progress - Current progress (0.0 to 1.0)
             * @private
             */
            notifyProgress(progress) {
                for (const callback of this.progressCallbacks) {
                    try {
                        callback(progress);
                    } catch (e) {
                        console.error('Error in progress callback:', e);
                    }
                }
            }

            /**
             * Check if currently playing
             * @returns {boolean} True if audio is playing
             */
            isCurrentlyPlaying() {
                return this.isPlaying;
            }

            /**
             * Get the duration of the current audio buffer
             * @returns {number} Duration in seconds
             */
            getDuration() {
                return this.duration;
            }
        }

        // ProgressTracker class
        class ProgressTracker {
            constructor() {
                this.total = 0;
                this.current = 0;
                this.updateCallbacks = [];
            }

            /**
             * Set the total amount for progress tracking
             * @param {number} total - Total bytes or units to track
             */
            setTotal(total) {
                this.total = total;
                this.current = 0;
                this.notifyUpdate();
            }

            /**
             * Update current progress
             * @param {number} current - Current bytes or units completed
             */
            updateProgress(current) {
                this.current = Math.min(current, this.total);
                this.notifyUpdate();
            }

            /**
             * Get current progress information
             * @returns {Object} Progress information with current, total, percentage, and bytesTransferred
             */
            getProgress() {
                const percentage = this.total > 0 ? (this.current / this.total) * 100 : 0;
                
                return {
                    current: this.current,
                    total: this.total,
                    percentage: percentage,
                    bytesTransferred: this.current
                };
            }

            /**
             * Register a callback for progress updates
             * @param {Function} callback - Callback function that receives ProgressInfo object
             */
            onUpdate(callback) {
                if (typeof callback === 'function') {
                    this.updateCallbacks.push(callback);
                }
            }

            /**
             * Clear all update callbacks
             */
            clearCallbacks() {
                this.updateCallbacks = [];
            }

            /**
             * Reset progress to zero
             */
            reset() {
                this.current = 0;
                this.total = 0;
                this.notifyUpdate();
            }

            /**
             * Notify all registered callbacks of progress update
             * @private
             */
            notifyUpdate() {
                const progressInfo = this.getProgress();
                
                for (const callback of this.updateCallbacks) {
                    try {
                        callback(progressInfo);
                    } catch (e) {
                        console.error('Error in progress update callback:', e);
                    }
                }
            }

            /**
             * Update UI elements for real-time display
             * @param {string} mode - 'emitter' or 'receiver'
             * @param {Object} progressInfo - Progress information object
             */
            updateUI(mode, progressInfo) {
                const prefix = mode === 'emitter' ? 'emitter' : 'receiver';
                
                // Get UI elements
                const progressContainer = document.getElementById(`${prefix}Progress`);
                const percentageElement = document.getElementById(`${prefix}Percentage`);
                const progressBar = document.getElementById(`${prefix}ProgressBar`);
                const detailsElement = document.getElementById(`${prefix}Details`);
                
                if (!progressContainer || !percentageElement || !progressBar || !detailsElement) {
                    return;
                }
                
                // Show progress container
                progressContainer.classList.add('active');
                
                // Update percentage display
                percentageElement.textContent = `${Math.round(progressInfo.percentage)}%`;
                
                // Update progress bar width
                progressBar.style.width = `${progressInfo.percentage}%`;
                
                // Update details text
                detailsElement.textContent = `${progressInfo.current} / ${progressInfo.total} bytes`;
            }

            /**
             * Hide UI progress display
             * @param {string} mode - 'emitter' or 'receiver'
             */
            hideUI(mode) {
                const prefix = mode === 'emitter' ? 'emitter' : 'receiver';
                const progressContainer = document.getElementById(`${prefix}Progress`);
                
                if (progressContainer) {
                    progressContainer.classList.remove('active');
                }
            }
        }

        // AudioVisualizer class - Visualizes audio output and input
        class AudioVisualizer {
            /**
             * Create an audio visualizer
             * @param {string} canvasId - ID of the canvas element for waveform
             * @param {string} levelFillId - ID of the level meter fill element (optional)
             * @param {string} levelPeakId - ID of the level meter peak indicator (optional)
             */
            constructor(canvasId, levelFillId = null, levelPeakId = null) {
                this.canvas = document.getElementById(canvasId);
                this.levelFill = levelFillId ? document.getElementById(levelFillId) : null;
                this.levelPeak = levelPeakId ? document.getElementById(levelPeakId) : null;
                
                this.ctx = this.canvas ? this.canvas.getContext('2d') : null;
                this.isActive = false;
                this.animationId = null;
                
                // Audio analysis
                this.audioContext = null;
                this.analyser = null;
                this.dataArray = null;
                this.bufferLength = 0;
                
                // Peak detection
                this.peakLevel = 0;
                this.peakDecay = 0.95;
                this.peakHoldTime = 1000; // ms
                this.lastPeakTime = 0;
                
                // Initialize canvas if available
                if (this.canvas && this.ctx) {
                    this.initializeCanvas();
                }
            }

            /**
             * Initialize canvas with proper dimensions
             */
            initializeCanvas() {
                // Set canvas size to match display size
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * window.devicePixelRatio;
                this.canvas.height = rect.height * window.devicePixelRatio;
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            }

            /**
             * Start visualizing audio from an audio node
             * @param {AudioNode} audioNode - The audio node to visualize
             * @param {AudioContext} audioContext - The audio context
             */
            startVisualization(audioNode, audioContext) {
                if (!audioNode || !audioContext) {
                    return;
                }

                this.audioContext = audioContext;
                
                // Create analyser node if not exists
                if (!this.analyser) {
                    this.analyser = audioContext.createAnalyser();
                    this.analyser.fftSize = 2048;
                    this.bufferLength = this.analyser.frequencyBinCount;
                    this.dataArray = new Uint8Array(this.bufferLength);
                }

                // Connect audio node to analyser
                try {
                    audioNode.connect(this.analyser);
                } catch (e) {
                    // Node might already be connected
                }

                this.isActive = true;
                this.animate();
            }

            /**
             * Start visualizing from audio data stream (for input monitoring)
             * @param {Function} getAudioLevel - Function that returns current audio level (0-1)
             */
            startLevelMonitoring(getAudioLevel) {
                this.getAudioLevel = getAudioLevel;
                this.isActive = true;
                this.animateLevelMeter();
            }

            /**
             * Stop visualization
             */
            stopVisualization() {
                this.isActive = false;
                
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }

                // Clear canvas
                if (this.ctx && this.canvas) {
                    const rect = this.canvas.getBoundingClientRect();
                    this.ctx.clearRect(0, 0, rect.width, rect.height);
                }

                // Reset level meter
                if (this.levelFill) {
                    this.levelFill.style.width = '0%';
                }
                if (this.levelPeak) {
                    this.levelPeak.classList.remove('active');
                }
            }

            /**
             * Animation loop for waveform visualization
             */
            animate() {
                if (!this.isActive || !this.analyser || !this.ctx || !this.canvas) {
                    return;
                }

                this.animationId = requestAnimationFrame(() => this.animate());

                // Get waveform data
                this.analyser.getByteTimeDomainData(this.dataArray);

                // Get canvas dimensions
                const rect = this.canvas.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;

                // Clear canvas
                this.ctx.fillStyle = '#1a1a1a';
                this.ctx.fillRect(0, 0, width, height);

                // Draw waveform
                this.ctx.lineWidth = 2;
                this.ctx.strokeStyle = '#667eea';
                this.ctx.beginPath();

                const sliceWidth = width / this.bufferLength;
                let x = 0;

                for (let i = 0; i < this.bufferLength; i++) {
                    const v = this.dataArray[i] / 128.0;
                    const y = (v * height) / 2;

                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }

                    x += sliceWidth;
                }

                this.ctx.lineTo(width, height / 2);
                this.ctx.stroke();

                // Calculate and display level
                this.updateLevelFromWaveform();
            }

            /**
             * Animation loop for level meter only
             */
            animateLevelMeter() {
                if (!this.isActive) {
                    return;
                }

                this.animationId = requestAnimationFrame(() => this.animateLevelMeter());

                // Get audio level from callback
                const level = this.getAudioLevel ? this.getAudioLevel() : 0;
                
                // Update level meter
                this.updateLevelMeter(level);
            }

            /**
             * Update level meter from waveform data
             */
            updateLevelFromWaveform() {
                if (!this.dataArray) {
                    return;
                }

                // Calculate RMS level
                let sum = 0;
                for (let i = 0; i < this.bufferLength; i++) {
                    const normalized = (this.dataArray[i] - 128) / 128;
                    sum += normalized * normalized;
                }
                const rms = Math.sqrt(sum / this.bufferLength);
                const level = Math.min(rms * 2, 1.0); // Scale and clamp

                this.updateLevelMeter(level);
            }

            /**
             * Update level meter display
             * @param {number} level - Audio level (0-1)
             */
            updateLevelMeter(level) {
                if (!this.levelFill) {
                    return;
                }

                // Update fill width
                const percentage = level * 100;
                this.levelFill.style.width = `${percentage}%`;

                // Update peak indicator
                const now = Date.now();
                
                if (level > this.peakLevel) {
                    this.peakLevel = level;
                    this.lastPeakTime = now;
                    
                    if (this.levelPeak) {
                        this.levelPeak.classList.add('active');
                    }
                } else {
                    // Decay peak
                    if (now - this.lastPeakTime > this.peakHoldTime) {
                        this.peakLevel *= this.peakDecay;
                        
                        if (this.peakLevel < 0.01) {
                            this.peakLevel = 0;
                            if (this.levelPeak) {
                                this.levelPeak.classList.remove('active');
                            }
                        }
                    }
                }
            }

            /**
             * Show visualizer container
             */
            show() {
                const visualizer = this.canvas ? this.canvas.closest('.audio-visualizer') : null;
                if (visualizer) {
                    visualizer.classList.add('active');
                }
            }

            /**
             * Hide visualizer container
             */
            hide() {
                const visualizer = this.canvas ? this.canvas.closest('.audio-visualizer') : null;
                if (visualizer) {
                    visualizer.classList.remove('active');
                }
            }
        }

        // EmitterController class - Wires up emitter mode functionality
        class EmitterController {
            constructor(modeController, dataProcessor, inputHandler) {
                this.modeController = modeController;
                this.dataProcessor = dataProcessor;
                this.inputHandler = inputHandler;
                this.audioEncoder = new AudioEncoder();
                this.audioPlayer = new AudioPlayer();
                this.progressTracker = new ProgressTracker();
                this.audioVisualizer = new AudioVisualizer('emitterWaveform');
                this.isTransmitting = false;
                
                this.sendButton = document.getElementById('sendBtn');
                this.statusElement = document.getElementById('emitterStatus');
                
                // Sync components
                this.syncController = new SyncController();
                this.calibrationGenerator = new CalibrationSignalGenerator();
                this.syncUIManager = new SyncUIManager('emitter');
                this.isSyncing = false;
                
                // Connect sync components
                this.syncController.setCalibrationGenerator(this.calibrationGenerator);
                
                // Check Web Audio API availability on initialization
                this.checkWebAudioSupport();
                
                this.initializeEventListeners();
                this.initializeSyncEventListeners();
            }

            /**
             * Check if Web Audio API is available
             */
            checkWebAudioSupport() {
                if (!window.AudioContext && !window.webkitAudioContext) {
                    this.showError('Web Audio API is not supported in this browser. Please use a modern browser like Chrome, Firefox, Safari, or Edge.');
                    this.sendButton.disabled = true;
                }
            }

            /**
             * Initialize event listeners for emitter mode
             */
            initializeEventListeners() {
                // Connect send button to encoding pipeline
                this.sendButton.addEventListener('click', () => {
                    this.handleSendClick();
                });
            }

            /**
             * Initialize sync event listeners
             */
            initializeSyncEventListeners() {
                const syncBtn = document.getElementById('emitterSyncBtn');
                
                if (syncBtn) {
                    syncBtn.addEventListener('click', () => {
                        this.handleSyncClick();
                    });
                }
                
                // Listen for sync state changes
                this.syncController.onStateChange((newState, oldState) => {
                    this.handleSyncStateChange(newState, oldState);
                });
            }

            /**
             * Handle sync button click
             */
            handleSyncClick() {
                const currentState = this.syncController.getSyncState();
                
                if (currentState === 'idle' || currentState === 'error') {
                    this.startEmitterSync();
                } else if (currentState === 'transmitting') {
                    this.stopEmitterSync();
                }
            }

            /**
             * Start emitter sync transmission
             */
            startEmitterSync() {
                if (this.isSyncing || this.isTransmitting) {
                    return;
                }
                
                this.isSyncing = true;
                
                // Lock mode switching
                this.modeController.lockMode();
                
                // Disable normal transmission controls
                this.sendButton.disabled = true;
                this.inputHandler.textInput.disabled = true;
                this.inputHandler.fileInput.disabled = true;
                
                // Start sync transmission
                this.syncController.startEmitterSync();
                
                // Update UI
                this.syncUIManager.updateSyncStatus('transmitting', 'ðŸ“¡ Transmitting calibration signal...');
            }

            /**
             * Stop emitter sync transmission
             */
            stopEmitterSync() {
                if (!this.isSyncing) {
                    return;
                }
                
                // Stop sync transmission
                this.syncController.stopEmitterSync();
                
                this.isSyncing = false;
                
                // Unlock mode switching
                this.modeController.unlockMode();
                
                // Restore normal transmission controls
                this.inputHandler.updateSendButtonState();
                this.inputHandler.textInput.disabled = false;
                this.inputHandler.fileInput.disabled = false;
                
                // Update UI
                this.syncUIManager.updateSyncStatus('idle', 'Ready to transmit calibration signal');
            }

            /**
             * Handle sync state changes
             * @param {string} newState - New sync state
             * @param {string} oldState - Previous sync state
             */
            handleSyncStateChange(newState, oldState) {
                // Update UI button state
                this.syncUIManager.updateSyncButtonState(newState);
                
                // Handle state-specific logic
                switch (newState) {
                    case 'transmitting':
                        this.syncUIManager.updateSyncStatus('transmitting', 'ðŸ“¡ Transmitting calibration signal...');
                        break;
                    
                    case 'idle':
                        if (oldState === 'transmitting') {
                            this.syncUIManager.updateSyncStatus('idle', 'Calibration transmission stopped');
                        }
                        break;
                    
                    case 'error':
                        this.syncUIManager.showSyncError({
                            type: 'transmission',
                            message: 'Failed to transmit calibration signal'
                        });
                        break;
                }
            }

            /**
             * Handle send button click - main transmission workflow
             */
            async handleSendClick() {
                // Prevent multiple simultaneous transmissions
                if (this.isTransmitting) {
                    return;
                }

                // Get current input data
                const preparedData = this.inputHandler.getCurrentInput();
                
                if (!preparedData || !preparedData.data || preparedData.data.length === 0) {
                    this.showError('No data to send. Please enter text or select a file.');
                    return;
                }

                try {
                    // Start transmission
                    this.startTransmission();

                    // Encode data to audio
                    const audioBuffer = this.audioEncoder.encode(preparedData);

                    // Set up progress tracking
                    this.setupProgressTracking(preparedData.data.length);
                    
                    // Set up visualization callback
                    this.audioPlayer.onPlaybackStart(() => {
                        if (this.audioPlayer.audioContext && this.audioPlayer.sourceNode) {
                            this.audioVisualizer.startVisualization(
                                this.audioPlayer.sourceNode,
                                this.audioPlayer.audioContext
                            );
                        }
                    });

                    // Play the encoded audio
                    await this.audioPlayer.play(audioBuffer);

                    // Transmission complete
                    this.completeTransmission();

                } catch (error) {
                    this.handleTransmissionError(error);
                }
            }

            /**
             * Start transmission - lock UI and update state
             */
            startTransmission() {
                this.isTransmitting = true;
                
                // Lock mode switching
                this.modeController.lockMode();
                
                // Disable send button and add loading state
                this.sendButton.disabled = true;
                this.sendButton.classList.add('loading');
                
                // Clear any previous status messages
                this.hideStatus();
                
                // Show progress container
                this.progressTracker.hideUI('emitter');
                
                // Show audio visualizer
                this.audioVisualizer.show();
            }

            /**
             * Set up progress tracking for transmission
             * @param {number} totalBytes - Total bytes being transmitted
             */
            setupProgressTracking(totalBytes) {
                // Set total bytes for progress tracker
                this.progressTracker.setTotal(totalBytes);
                
                // Clear any previous callbacks
                this.audioPlayer.clearProgressCallbacks();
                this.progressTracker.clearCallbacks();
                
                // Register progress callback from audio player
                this.audioPlayer.onProgressUpdate((audioProgress) => {
                    // Convert audio progress (0-1) to bytes transmitted
                    const bytesTransmitted = Math.floor(audioProgress * totalBytes);
                    this.progressTracker.updateProgress(bytesTransmitted);
                });
                
                // Register progress tracker callback to update UI
                this.progressTracker.onUpdate((progressInfo) => {
                    this.progressTracker.updateUI('emitter', progressInfo);
                });
            }

            /**
             * Complete transmission - unlock UI and show success
             */
            completeTransmission() {
                this.isTransmitting = false;
                
                // Unlock mode switching
                this.modeController.unlockMode();
                
                // Re-enable send button and remove loading state
                this.sendButton.classList.remove('loading');
                this.inputHandler.updateSendButtonState();
                
                // Stop audio visualization
                this.audioVisualizer.stopVisualization();
                
                // Show success notification
                this.showSuccess('Transmission completed successfully!');
                
                // Keep progress display visible to show 100%
                // User can see final state before starting new transmission
            }

            /**
             * Handle transmission error
             * @param {Error} error - The error that occurred
             */
            handleTransmissionError(error) {
                this.isTransmitting = false;
                
                // Unlock mode switching
                this.modeController.unlockMode();
                
                // Re-enable send button and remove loading state
                this.sendButton.classList.remove('loading');
                this.inputHandler.updateSendButtonState();
                
                // Stop audio playback if still playing
                this.audioPlayer.stop();
                
                // Stop audio visualization
                this.audioVisualizer.stopVisualization();
                this.audioVisualizer.hide();
                
                // Hide progress display
                this.progressTracker.hideUI('emitter');
                
                // Show error message with clear instructions
                let errorMessage = 'Transmission failed: ';
                let instructions = '';
                
                if (error.name === 'NotAllowedError') {
                    errorMessage += 'Audio playback was blocked by the browser.';
                    instructions = 'Please check your browser settings and allow audio playback for this page, then try again.';
                } else if (error.name === 'NotSupportedError') {
                    errorMessage += 'Web Audio API is not supported in this browser.';
                    instructions = 'Please use a modern browser like Chrome, Firefox, Safari, or Edge.';
                } else if (error.message && error.message.includes('Web Audio API')) {
                    errorMessage += 'Web Audio API is not available.';
                    instructions = 'Please ensure you are using a compatible browser and try again.';
                } else {
                    errorMessage += error.message || 'An unknown error occurred.';
                    instructions = 'Please try again. If the problem persists, try refreshing the page.';
                }
                
                this.showError(errorMessage + ' ' + instructions);
            }

            /**
             * Show success message
             * @param {string} message - Success message to display
             */
            showSuccess(message) {
                this.statusElement.textContent = message;
                this.statusElement.className = 'status-message success active';
            }

            /**
             * Show error message
             * @param {string} message - Error message to display
             */
            showError(message) {
                this.statusElement.textContent = message;
                this.statusElement.className = 'status-message error active';
            }

            /**
             * Hide status message
             */
            hideStatus() {
                this.statusElement.className = 'status-message';
                this.statusElement.textContent = '';
            }

            /**
             * Check if currently transmitting
             * @returns {boolean} True if transmission is in progress
             */
            isCurrentlyTransmitting() {
                return this.isTransmitting;
            }
        }

        // GoertzelFilter class - Implements Goertzel algorithm for frequency detection
        class GoertzelFilter {
            /**
             * Create a Goertzel filter for a specific target frequency
             * @param {number} targetFrequency - The frequency to detect (Hz)
             * @param {number} sampleRate - Sample rate of the audio (Hz)
             * @param {number} windowSize - Number of samples in the analysis window
             */
            constructor(targetFrequency, sampleRate, windowSize) {
                this.targetFrequency = targetFrequency;
                this.sampleRate = sampleRate;
                this.windowSize = windowSize;
                
                // Calculate Goertzel coefficient
                // k = (int)(0.5 + ((windowSize * targetFrequency) / sampleRate))
                const k = Math.round((windowSize * targetFrequency) / sampleRate);
                
                // omega = (2 * PI * k) / windowSize
                const omega = (2 * Math.PI * k) / windowSize;
                
                // coefficient = 2 * cos(omega)
                this.coefficient = 2 * Math.cos(omega);
                
                // For magnitude calculation
                this.cosine = Math.cos(omega);
                this.sine = Math.sin(omega);
            }

            /**
             * Process audio samples and return magnitude at target frequency
             * @param {Float32Array} samples - Audio samples to analyze
             * @returns {number} Magnitude of the target frequency component
             */
            process(samples) {
                let s0 = 0;
                let s1 = 0;
                let s2 = 0;
                
                // Process each sample through the Goertzel filter
                for (let i = 0; i < samples.length; i++) {
                    s0 = samples[i] + this.coefficient * s1 - s2;
                    s2 = s1;
                    s1 = s0;
                }
                
                // Calculate magnitude
                // magnitude = sqrt(s1^2 + s2^2 - coefficient * s1 * s2)
                const real = s1 - s2 * this.cosine;
                const imag = s2 * this.sine;
                const magnitude = Math.sqrt(real * real + imag * imag);
                
                return magnitude;
            }

            /**
             * Process audio samples and return normalized magnitude (0.0 to 1.0)
             * @param {Float32Array} samples - Audio samples to analyze
             * @returns {number} Normalized magnitude (0.0 to 1.0)
             */
            processNormalized(samples) {
                const magnitude = this.process(samples);
                
                // Normalize by window size for consistent results
                // This gives us a value roughly proportional to signal amplitude
                return magnitude / this.windowSize;
            }
        }

        // FrequencyDetector class - Uses Goertzel filters for FSK decoding
        class FrequencyDetector {
            /**
             * Create a frequency detector for FSK decoding
             * @param {number} sampleRate - Sample rate of the audio (default: 48000 Hz)
             */
            constructor(sampleRate = 48000) {
                this.sampleRate = sampleRate;
                this.baudRate = 100; // Bits per second
                this.bitDuration = sampleRate / this.baudRate; // Samples per bit
                
                // Frequencies to detect
                this.freq0 = 4500; // Bit 0 frequency
                this.freq1 = 6500; // Bit 1 frequency
                this.freqPreamble = 5500; // Preamble frequency
                
                // Window size for Goertzel analysis
                // Use the bit duration as window size for optimal detection
                this.windowSize = Math.floor(this.bitDuration);
                
                // Create Goertzel filters for each frequency
                this.filter0 = new GoertzelFilter(this.freq0, this.sampleRate, this.windowSize);
                this.filter1 = new GoertzelFilter(this.freq1, this.sampleRate, this.windowSize);
                this.filterPreamble = new GoertzelFilter(this.freqPreamble, this.sampleRate, this.windowSize);
                
                // Threshold for bit decision (relative magnitude difference)
                // If mag1 / mag0 > threshold, it's a 1 bit
                // If mag0 / mag1 > threshold, it's a 0 bit
                this.bitDecisionThreshold = 1.5;
                
                // Threshold for preamble detection (absolute magnitude)
                // Preamble should have strong signal at 5500 Hz
                this.preambleThreshold = 0.1;
            }

            /**
             * Detect which bit (0 or 1) is present in the audio samples
             * @param {Float32Array} samples - Audio samples to analyze (should be ~1 bit duration)
             * @returns {number|null} Detected bit (0 or 1) or null if no clear signal
             */
            detectBit(samples) {
                // Ensure we have enough samples
                if (samples.length < this.windowSize) {
                    return null;
                }
                
                // Extract window of samples (use first windowSize samples)
                const window = samples.slice(0, this.windowSize);
                
                // Get magnitudes at both frequencies
                const mag0 = this.filter0.processNormalized(window);
                const mag1 = this.filter1.processNormalized(window);
                
                // Threshold-based bit decision
                // Compare relative magnitudes to determine which frequency is stronger
                if (mag1 > mag0 * this.bitDecisionThreshold) {
                    // Frequency 1 (6500 Hz) is dominant -> bit 1
                    return 1;
                } else if (mag0 > mag1 * this.bitDecisionThreshold) {
                    // Frequency 0 (4500 Hz) is dominant -> bit 0
                    return 0;
                } else {
                    // No clear signal or ambiguous
                    return null;
                }
            }

            /**
             * Detect if preamble (5500 Hz tone) is present in the audio samples
             * @param {Float32Array} samples - Audio samples to analyze
             * @returns {boolean} True if preamble is detected
             */
            detectPreamble(samples) {
                // Ensure we have enough samples
                if (samples.length < this.windowSize) {
                    return false;
                }
                
                // Extract window of samples
                const window = samples.slice(0, this.windowSize);
                
                // Get magnitude at preamble frequency
                const magPreamble = this.filterPreamble.processNormalized(window);
                
                // Also check that other frequencies are not dominant
                // (to avoid false positives from data transmission)
                const mag0 = this.filter0.processNormalized(window);
                const mag1 = this.filter1.processNormalized(window);
                
                // Preamble should have strong 5500 Hz signal
                // and weaker signals at data frequencies
                const isPreambleStrong = magPreamble > this.preambleThreshold;
                const areDataFreqsWeak = magPreamble > mag0 * 1.2 && magPreamble > mag1 * 1.2;
                
                return isPreambleStrong && areDataFreqsWeak;
            }

            /**
             * Analyze a continuous stream of audio and detect bits
             * @param {Float32Array} samples - Audio samples to analyze
             * @returns {Array<number>} Array of detected bits (0 or 1)
             */
            detectBitStream(samples) {
                const bits = [];
                const stride = this.windowSize; // Move by one bit duration each time
                
                // Process samples in windows
                for (let i = 0; i + this.windowSize <= samples.length; i += stride) {
                    const window = samples.slice(i, i + this.windowSize);
                    const bit = this.detectBit(window);
                    
                    if (bit !== null) {
                        bits.push(bit);
                    }
                }
                
                return bits;
            }

            /**
             * Get the window size (samples per bit)
             * @returns {number} Number of samples in one bit duration
             */
            getWindowSize() {
                return this.windowSize;
            }

            /**
             * Set the bit decision threshold
             * @param {number} threshold - New threshold value (default: 1.5)
             */
            setBitDecisionThreshold(threshold) {
                this.bitDecisionThreshold = threshold;
            }

            /**
             * Set the preamble detection threshold
             * @param {number} threshold - New threshold value (default: 0.1)
             */
            setPreambleThreshold(threshold) {
                this.preambleThreshold = threshold;
            }

            /**
             * Get magnitude information for debugging
             * @param {Float32Array} samples - Audio samples to analyze
             * @returns {Object} Magnitudes at all three frequencies
             */
            getMagnitudes(samples) {
                if (samples.length < this.windowSize) {
                    return { mag0: 0, mag1: 0, magPreamble: 0 };
                }
                
                const window = samples.slice(0, this.windowSize);
                
                return {
                    mag0: this.filter0.processNormalized(window),
                    mag1: this.filter1.processNormalized(window),
                    magPreamble: this.filterPreamble.processNormalized(window)
                };
            }
        }

        // AudioDecoder class - Decodes FSK audio signals back to binary data
        class AudioDecoder {
            /**
             * Create an audio decoder for FSK demodulation
             * @param {number} sampleRate - Sample rate of the audio (default: 48000 Hz)
             */
            constructor(sampleRate = 48000) {
                this.sampleRate = sampleRate;
                this.baudRate = 100; // Bits per second
                this.bitDuration = sampleRate / this.baudRate; // Samples per bit
                
                // Create frequency detector
                this.frequencyDetector = new FrequencyDetector(sampleRate);
                
                // State machine for decoding
                this.state = 'IDLE'; // States: IDLE, PREAMBLE_DETECTED, DECODING_HEADER, DECODING_CHUNKS
                
                // Buffers
                this.audioBuffer = new Float32Array(0); // Accumulated audio samples
                this.receivedChunks = []; // Array of decoded chunks
                
                // Header information
                this.header = null;
                this.expectedChunks = 0;
                
                // Callbacks
                this.chunkReceivedCallbacks = [];
                this.transmissionCompleteCallbacks = [];
                this.errorCallbacks = [];
                
                // Preamble detection
                this.preambleDetectionWindow = Math.floor(5.0 * sampleRate); // 5000ms window
                this.preambleConfirmationCount = 0;
                this.preambleConfirmationThreshold = 10; // Need multiple confirmations
                
                // Preamble timeout tracking (30 seconds)
                this.preambleTimeout = 30000; // 30 seconds in milliseconds
                this.listeningStartTime = null;
                this.preambleTimeoutTimer = null;
                
                // Checksum error tracking
                this.checksumErrors = 0;
                this.maxChecksumErrors = 10; // Maximum consecutive checksum errors before giving up
                
                // Data processor for checksum verification
                this.dataProcessor = new DataProcessor();
            }

            /**
             * Start listening for transmissions
             */
            startListening() {
                this.reset();
                this.state = 'IDLE';
                this.listeningStartTime = Date.now();
                this.startPreambleTimeoutTimer();
            }

            /**
             * Stop listening for transmissions
             */
            stopListening() {
                this.reset();
                this.clearPreambleTimeoutTimer();
            }

            /**
             * Reset decoder state
             */
            reset() {
                this.state = 'IDLE';
                this.audioBuffer = new Float32Array(0);
                this.receivedChunks = [];
                this.header = null;
                this.expectedChunks = 0;
                this.preambleConfirmationCount = 0;
                this.checksumErrors = 0;
            }

            /**
             * Start preamble timeout timer
             */
            startPreambleTimeoutTimer() {
                this.clearPreambleTimeoutTimer();
                this.preambleTimeoutTimer = setTimeout(() => {
                    if (this.state === 'IDLE') {
                        this.notifyError({
                            type: 'PREAMBLE_TIMEOUT',
                            message: 'No transmission detected within 30 seconds. Please ensure the emitter is playing audio and the volume is adequate.'
                        });
                    }
                }, this.preambleTimeout);
            }

            /**
             * Clear preamble timeout timer
             */
            clearPreambleTimeoutTimer() {
                if (this.preambleTimeoutTimer) {
                    clearTimeout(this.preambleTimeoutTimer);
                    this.preambleTimeoutTimer = null;
                }
            }

            /**
             * Process incoming audio data
             * @param {Float32Array} audioData - New audio samples to process
             */
            processAudioData(audioData) {
                // Append new audio data to buffer
                this.appendToBuffer(audioData);
                
                // Process based on current state
                switch (this.state) {
                    case 'IDLE':
                        this.detectPreambleState();
                        break;
                    
                    case 'PREAMBLE_DETECTED':
                        this.waitForPreambleEnd();
                        break;
                    
                    case 'DECODING_HEADER':
                        this.decodeHeaderState();
                        break;
                    
                    case 'DECODING_CHUNKS':
                        this.decodeChunksState();
                        break;
                }
            }

            /**
             * Detect preamble in audio buffer
             * @param {Float32Array} audioData - Audio samples to check
             * @returns {boolean} True if preamble is detected
             */
            detectPreamble(audioData) {
                const windowSize = this.frequencyDetector.getWindowSize();
                
                // Need at least one window of samples
                if (audioData.length < windowSize) {
                    return false;
                }
                
                // Check multiple windows for preamble
                let detectionCount = 0;
                const numWindows = Math.min(10, Math.floor(audioData.length / windowSize));
                
                for (let i = 0; i < numWindows; i++) {
                    const start = i * windowSize;
                    const window = audioData.slice(start, start + windowSize);
                    
                    if (this.frequencyDetector.detectPreamble(window)) {
                        detectionCount++;
                    }
                }
                
                // Require multiple confirmations to avoid false positives
                return detectionCount >= Math.min(5, numWindows);
            }

            /**
             * State: Detect preamble
             */
            detectPreambleState() {
                const windowSize = this.frequencyDetector.getWindowSize();
                
                // Keep buffer size manageable while searching for preamble
                if (this.audioBuffer.length > this.preambleDetectionWindow * 2) {
                    // Discard old samples, keep recent ones
                    this.audioBuffer = this.audioBuffer.slice(-this.preambleDetectionWindow);
                }
                
                // Check if we have enough samples to detect preamble
                if (this.audioBuffer.length < windowSize * 10) {
                    return;
                }
                
                // Try to detect preamble
                if (this.detectPreamble(this.audioBuffer)) {
                    this.state = 'PREAMBLE_DETECTED';
                    // Clear preamble timeout since we detected it
                    this.clearPreambleTimeoutTimer();
                    // Clear buffer to start fresh after preamble
                    this.audioBuffer = new Float32Array(0);
                }
            }

            /**
             * State: Wait for preamble to end
             */
            waitForPreambleEnd() {
                const windowSize = this.frequencyDetector.getWindowSize();
                
                // Wait for enough samples to confirm preamble has ended
                if (this.audioBuffer.length < windowSize * 5) {
                    return;
                }
                
                // Check if preamble is still present
                const stillPreamble = this.detectPreamble(this.audioBuffer.slice(-windowSize * 5));
                
                if (!stillPreamble) {
                    // Preamble has ended, start decoding header
                    this.state = 'DECODING_HEADER';
                    // Keep buffer for header decoding
                }
            }

            /**
             * State: Decode header
             */
            decodeHeaderState() {
                // Try to decode header
                const header = this.decodeHeader(this.audioBuffer);
                
                if (header) {
                    this.header = header;
                    this.expectedChunks = header.totalChunks;
                    this.receivedChunks = [];
                    this.state = 'DECODING_CHUNKS';
                    
                    // Remove decoded header samples from buffer
                    const headerBitCount = this.estimateHeaderBitCount(header);
                    const headerSampleCount = headerBitCount * this.bitDuration;
                    this.audioBuffer = this.audioBuffer.slice(Math.floor(headerSampleCount));
                }
            }

            /**
             * State: Decode chunks
             */
            decodeChunksState() {
                // Try to decode a chunk
                const chunk = this.decodeChunk(this.audioBuffer);
                
                if (chunk) {
                    // Verify chunk checksum
                    const chunkData = new Uint8Array([
                        (chunk.index >> 8) & 0xFF,
                        chunk.index & 0xFF,
                        chunk.data.length,
                        ...chunk.data
                    ]);
                    
                    if (this.dataProcessor.verifyChecksum(chunkData, chunk.checksum)) {
                        // Valid chunk received - reset error counter
                        this.checksumErrors = 0;
                        this.receivedChunks.push(chunk);
                        this.notifyChunkReceived(chunk);
                        
                        // Check if transmission is complete
                        if (this.receivedChunks.length >= this.expectedChunks) {
                            this.notifyTransmissionComplete();
                            this.reset();
                        } else {
                            // Remove decoded chunk samples from buffer
                            const chunkBitCount = this.estimateChunkBitCount(chunk);
                            const chunkSampleCount = chunkBitCount * this.bitDuration;
                            this.audioBuffer = this.audioBuffer.slice(Math.floor(chunkSampleCount));
                        }
                    } else {
                        // Checksum mismatch - increment error counter
                        this.checksumErrors++;
                        
                        if (this.checksumErrors >= this.maxChecksumErrors) {
                            // Too many consecutive checksum errors
                            this.notifyError({
                                type: 'CHECKSUM_MISMATCH',
                                message: 'Multiple checksum errors detected. The audio signal may be corrupted or too weak. Please move devices closer together and ensure minimal background noise.',
                                receivedChunks: this.receivedChunks.length,
                                expectedChunks: this.expectedChunks
                            });
                            this.reset();
                        } else {
                            // Skip some samples and try again
                            const skipSamples = Math.floor(this.bitDuration * 11); // Skip one byte worth
                            this.audioBuffer = this.audioBuffer.slice(skipSamples);
                        }
                    }
                }
            }

            /**
             * Decode header from audio buffer
             * @param {Float32Array} audioData - Audio samples containing header
             * @returns {Object|null} Decoded header or null if not enough data
             */
            decodeHeader(audioData) {
                // Estimate minimum header size: magic(2) + type(1) + filenameLen(1) + chunks(2) + size(4) + checksum(2) = 12 bytes minimum
                // Each byte = 11 bits (start + 8 data + parity + stop)
                const minHeaderBits = 12 * 11;
                const minHeaderSamples = minHeaderBits * this.bitDuration;
                
                if (audioData.length < minHeaderSamples) {
                    return null;
                }
                
                // Decode bits from audio
                const bits = this.frequencyDetector.detectBitStream(audioData);
                
                if (bits.length < minHeaderBits) {
                    return null;
                }
                
                // Decode bytes from bits
                const bytes = this.decodeBytesFromBits(bits);
                
                if (bytes.length < 12) {
                    return null;
                }
                
                // Parse header
                let offset = 0;
                
                // Magic bytes (2 bytes): 0xAA 0x55
                const magic1 = bytes[offset++];
                const magic2 = bytes[offset++];
                
                if (magic1 !== 0xAA || magic2 !== 0x55) {
                    return null; // Invalid magic bytes
                }
                
                // Data type (1 byte): 0x01=text, 0x02=file
                const dataType = bytes[offset++];
                const type = dataType === 0x01 ? 'text' : 'file';
                
                // Filename length (1 byte)
                const filenameLength = bytes[offset++];
                
                // Filename (variable length, UTF-8)
                let filename = null;
                if (filenameLength > 0) {
                    if (bytes.length < offset + filenameLength) {
                        return null; // Not enough data
                    }
                    const filenameBytes = bytes.slice(offset, offset + filenameLength);
                    const decoder = new TextDecoder();
                    filename = decoder.decode(new Uint8Array(filenameBytes));
                    offset += filenameLength;
                }
                
                // Total chunks (2 bytes, big-endian)
                if (bytes.length < offset + 2) {
                    return null;
                }
                const totalChunks = (bytes[offset] << 8) | bytes[offset + 1];
                offset += 2;
                
                // Total data size (4 bytes, big-endian)
                if (bytes.length < offset + 4) {
                    return null;
                }
                const totalSize = (bytes[offset] << 24) | (bytes[offset + 1] << 16) | 
                                 (bytes[offset + 2] << 8) | bytes[offset + 3];
                offset += 4;
                
                // Header checksum (2 bytes)
                if (bytes.length < offset + 2) {
                    return null;
                }
                const headerChecksum = (bytes[offset] << 8) | bytes[offset + 1];
                offset += 2;
                
                // Verify header checksum
                const headerData = new Uint8Array(bytes.slice(0, offset - 2));
                if (!this.dataProcessor.verifyChecksum(headerData, headerChecksum)) {
                    return null; // Invalid header checksum
                }
                
                return {
                    type: type,
                    filename: filename,
                    totalChunks: totalChunks,
                    totalSize: totalSize
                };
            }

            /**
             * Decode a single chunk from audio buffer
             * @param {Float32Array} audioData - Audio samples containing chunk
             * @returns {Object|null} Decoded chunk or null if not enough data
             */
            decodeChunk(audioData) {
                // Minimum chunk size: index(2) + length(1) + checksum(2) = 5 bytes
                // Each byte = 11 bits
                const minChunkBits = 5 * 11;
                const minChunkSamples = minChunkBits * this.bitDuration;
                
                if (audioData.length < minChunkSamples) {
                    return null;
                }
                
                // Decode bits from audio
                const bits = this.frequencyDetector.detectBitStream(audioData);
                
                if (bits.length < minChunkBits) {
                    return null;
                }
                
                // Decode bytes from bits
                const bytes = this.decodeBytesFromBits(bits);
                
                if (bytes.length < 5) {
                    return null;
                }
                
                // Parse chunk
                let offset = 0;
                
                // Chunk index (2 bytes, big-endian)
                const chunkIndex = (bytes[offset] << 8) | bytes[offset + 1];
                offset += 2;
                
                // Data length (1 byte)
                const dataLength = bytes[offset++];
                
                // Data (variable length)
                if (bytes.length < offset + dataLength + 2) {
                    return null; // Not enough data
                }
                const chunkData = bytes.slice(offset, offset + dataLength);
                offset += dataLength;
                
                // Chunk checksum (2 bytes)
                const chunkChecksum = (bytes[offset] << 8) | bytes[offset + 1];
                
                return {
                    index: chunkIndex,
                    data: new Uint8Array(chunkData),
                    checksum: chunkChecksum
                };
            }

            /**
             * Decode bytes from bit stream with start/stop bit detection and parity checking
             * @param {Array<number>} bits - Array of bits (0 or 1)
             * @returns {Array<number>} Array of decoded bytes
             */
            decodeBytesFromBits(bits) {
                const bytes = [];
                let i = 0;
                
                while (i + 11 <= bits.length) {
                    // Look for start bit (0)
                    if (bits[i] !== 0) {
                        i++;
                        continue;
                    }
                    
                    // Extract 8 data bits (LSB first)
                    let byte = 0;
                    let onesCount = 0;
                    
                    for (let bit = 0; bit < 8; bit++) {
                        const bitValue = bits[i + 1 + bit];
                        if (bitValue === 1) {
                            byte |= (1 << bit);
                            onesCount++;
                        }
                    }
                    
                    // Check parity bit (even parity)
                    const parityBit = bits[i + 9];
                    const expectedParity = onesCount % 2;
                    
                    if (parityBit !== expectedParity) {
                        // Parity error - skip this byte
                        i++;
                        continue;
                    }
                    
                    // Check stop bit (1)
                    if (bits[i + 10] !== 1) {
                        // Invalid stop bit - skip
                        i++;
                        continue;
                    }
                    
                    // Valid byte decoded
                    bytes.push(byte);
                    i += 11; // Move to next byte
                }
                
                return bytes;
            }

            /**
             * Estimate number of bits in header
             * @param {Object} header - Header object
             * @returns {number} Estimated bit count
             */
            estimateHeaderBitCount(header) {
                // magic(2) + type(1) + filenameLen(1) + filename(variable) + chunks(2) + size(4) + checksum(2)
                const filenameLength = header.filename ? header.filename.length : 0;
                const byteCount = 12 + filenameLength;
                return byteCount * 11; // 11 bits per byte
            }

            /**
             * Estimate number of bits in chunk
             * @param {Object} chunk - Chunk object
             * @returns {number} Estimated bit count
             */
            estimateChunkBitCount(chunk) {
                // index(2) + length(1) + data(variable) + checksum(2)
                const byteCount = 5 + chunk.data.length;
                return byteCount * 11; // 11 bits per byte
            }

            /**
             * Append audio data to buffer
             * @param {Float32Array} audioData - Audio samples to append
             */
            appendToBuffer(audioData) {
                const newBuffer = new Float32Array(this.audioBuffer.length + audioData.length);
                newBuffer.set(this.audioBuffer, 0);
                newBuffer.set(audioData, this.audioBuffer.length);
                this.audioBuffer = newBuffer;
            }

            /**
             * Register callback for chunk received event
             * @param {Function} callback - Callback function that receives chunk object
             */
            onChunkReceived(callback) {
                if (typeof callback === 'function') {
                    this.chunkReceivedCallbacks.push(callback);
                }
            }

            /**
             * Register callback for transmission complete event
             * @param {Function} callback - Callback function called when transmission completes
             */
            onTransmissionComplete(callback) {
                if (typeof callback === 'function') {
                    this.transmissionCompleteCallbacks.push(callback);
                }
            }

            /**
             * Register callback for error events
             * @param {Function} callback - Callback function that receives error object
             */
            onError(callback) {
                if (typeof callback === 'function') {
                    this.errorCallbacks.push(callback);
                }
            }

            /**
             * Notify all chunk received callbacks
             * @param {Object} chunk - The received chunk
             */
            notifyChunkReceived(chunk) {
                for (const callback of this.chunkReceivedCallbacks) {
                    try {
                        callback(chunk);
                    } catch (e) {
                        console.error('Error in chunk received callback:', e);
                    }
                }
            }

            /**
             * Notify all transmission complete callbacks
             */
            notifyTransmissionComplete() {
                for (const callback of this.transmissionCompleteCallbacks) {
                    try {
                        callback();
                    } catch (e) {
                        console.error('Error in transmission complete callback:', e);
                    }
                }
            }

            /**
             * Notify all error callbacks
             * @param {Object} error - Error object with type and message
             */
            notifyError(error) {
                for (const callback of this.errorCallbacks) {
                    try {
                        callback(error);
                    } catch (e) {
                        console.error('Error in error callback:', e);
                    }
                }
            }

            /**
             * Get all received chunks
             * @returns {Array<Object>} Array of received chunks
             */
            getReceivedChunks() {
                return this.receivedChunks;
            }

            /**
             * Get header information
             * @returns {Object|null} Header object or null if not decoded yet
             */
            getHeader() {
                return this.header;
            }

            /**
             * Get current decoder state
             * @returns {string} Current state
             */
            getState() {
                return this.state;
            }
        }

        // AudioRecorder class - Captures audio from microphone
        class AudioRecorder {
            /**
             * Create an audio recorder for capturing microphone input
             * @param {number} sampleRate - Sample rate for recording (default: 48000 Hz)
             */
            constructor(sampleRate = 48000) {
                this.sampleRate = sampleRate;
                this.mediaStream = null;
                this.audioContext = null;
                this.sourceNode = null;
                this.processorNode = null;
                this.isRecording = false;
                this.hasPermission = false;
                this.audioDataCallbacks = [];
            }

            /**
             * Request microphone permission from the user
             * @returns {Promise<boolean>} Promise that resolves to true if permission granted
             */
            async requestPermission() {
                try {
                    // Check if getUserMedia is supported
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error('getUserMedia is not supported in this browser');
                    }

                    // Request microphone access
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: this.sampleRate
                        }
                    });

                    // Store the stream for later use
                    this.mediaStream = stream;
                    this.hasPermission = true;

                    return true;

                } catch (error) {
                    this.hasPermission = false;

                    // Handle specific error types
                    if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                        throw new Error('Microphone permission denied. Please allow microphone access in your browser settings.');
                    } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                        throw new Error('No microphone found. Please connect a microphone and try again.');
                    } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                        throw new Error('Microphone is already in use by another application.');
                    } else {
                        throw new Error('Failed to access microphone: ' + error.message);
                    }
                }
            }

            /**
             * Start recording audio from the microphone
             * @returns {Promise<void>} Promise that resolves when recording starts
             */
            async startRecording() {
                // Check if we have permission
                if (!this.hasPermission || !this.mediaStream) {
                    throw new Error('Microphone permission not granted. Call requestPermission() first.');
                }

                // Stop any existing recording
                if (this.isRecording) {
                    this.stopRecording();
                }

                try {
                    // Create audio context if needed
                    if (!this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                            sampleRate: this.sampleRate
                        });
                    }

                    // Resume audio context if suspended
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }

                    // Create source node from media stream
                    this.sourceNode = this.audioContext.createMediaStreamSource(this.mediaStream);

                    // Create script processor node for audio processing
                    // Buffer size: 4096 samples provides good balance between latency and processing
                    const bufferSize = 4096;
                    this.processorNode = this.audioContext.createScriptProcessor(bufferSize, 1, 1);

                    // Set up audio processing callback
                    this.processorNode.onaudioprocess = (event) => {
                        if (this.isRecording) {
                            // Get audio data from input buffer
                            const inputBuffer = event.inputBuffer;
                            const audioData = inputBuffer.getChannelData(0);

                            // Create a copy of the audio data
                            const audioDataCopy = new Float32Array(audioData);

                            // Notify all registered callbacks
                            this.notifyAudioData(audioDataCopy);
                        }
                    };

                    // Connect nodes: source -> processor -> destination
                    // Note: We connect to destination to keep the processing active,
                    // but we don't actually play the audio (it's just for processing)
                    this.sourceNode.connect(this.processorNode);
                    this.processorNode.connect(this.audioContext.destination);

                    this.isRecording = true;

                } catch (error) {
                    this.isRecording = false;
                    throw new Error('Failed to start recording: ' + error.message);
                }
            }

            /**
             * Stop recording audio
             */
            stopRecording() {
                if (!this.isRecording) {
                    return;
                }

                try {
                    // Disconnect audio nodes
                    if (this.processorNode) {
                        this.processorNode.disconnect();
                        this.processorNode.onaudioprocess = null;
                        this.processorNode = null;
                    }

                    if (this.sourceNode) {
                        this.sourceNode.disconnect();
                        this.sourceNode = null;
                    }

                    // Stop media stream tracks
                    if (this.mediaStream) {
                        const tracks = this.mediaStream.getTracks();
                        tracks.forEach(track => track.stop());
                        this.mediaStream = null;
                    }

                    // Close audio context
                    if (this.audioContext) {
                        this.audioContext.close();
                        this.audioContext = null;
                    }

                    this.isRecording = false;
                    this.hasPermission = false;

                } catch (error) {
                    console.error('Error stopping recording:', error);
                }
            }

            /**
             * Register a callback for audio data events
             * @param {Function} callback - Callback function that receives Float32Array of audio samples
             */
            onAudioData(callback) {
                if (typeof callback === 'function') {
                    this.audioDataCallbacks.push(callback);
                }
            }

            /**
             * Clear all audio data callbacks
             */
            clearAudioDataCallbacks() {
                this.audioDataCallbacks = [];
            }

            /**
             * Notify all registered callbacks with audio data
             * @param {Float32Array} audioData - Audio samples to send to callbacks
             * @private
             */
            notifyAudioData(audioData) {
                for (const callback of this.audioDataCallbacks) {
                    try {
                        callback(audioData);
                    } catch (error) {
                        console.error('Error in audio data callback:', error);
                    }
                }
            }

            /**
             * Check if currently recording
             * @returns {boolean} True if recording is active
             */
            isCurrentlyRecording() {
                return this.isRecording;
            }

            /**
             * Check if microphone permission has been granted
             * @returns {boolean} True if permission granted
             */
            hasPermissionGranted() {
                return this.hasPermission;
            }

            /**
             * Get the current sample rate
             * @returns {number} Sample rate in Hz
             */
            getSampleRate() {
                return this.sampleRate;
            }
        }

        // ReceiverController class - Wires up receiver mode functionality
        class ReceiverController {
            constructor(modeController, dataProcessor) {
                this.modeController = modeController;
                this.dataProcessor = dataProcessor;
                this.audioRecorder = new AudioRecorder();
                this.audioDecoder = new AudioDecoder();
                this.progressTracker = new ProgressTracker();
                this.audioVisualizer = new AudioVisualizer(null, 'receiverLevelFill', 'receiverLevelPeak');
                this.isReceiving = false;
                
                this.statusElement = document.getElementById('receiverStatus');
                this.dataDisplay = document.getElementById('dataDisplay');
                
                // Track received transmissions
                this.transmissionHistory = [];
                
                // Audio level tracking for visualization
                this.currentAudioLevel = 0;
                
                // Sync components
                this.syncController = new SyncController();
                this.syncUIManager = new SyncUIManager('receiver');
                this.decoderConfigurator = new DecoderConfigurator();
                this.isSyncing = false;
                this.syncAudioContext = null;
                this.syncAnalyzer = null;
                this.syncDetector = null;
                this.syncInterval = null;
                this.syncTimeout = null;
                
                this.initializeReceiverMode();
                this.initializeSyncEventListeners();
            }

            /**
             * Initialize receiver mode - request permission and start listening
             */
            async initializeReceiverMode() {
                try {
                    // Check Web Audio API support
                    if (!window.AudioContext && !window.webkitAudioContext) {
                        throw new Error('Web Audio API is not supported in this browser');
                    }
                    
                    // Check MediaDevices API support
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error('getUserMedia is not supported in this browser');
                    }
                    
                    // Request microphone permission
                    await this.audioRecorder.requestPermission();
                    
                    // Start recording
                    await this.audioRecorder.startRecording();
                    
                    // Start decoder listening
                    this.audioDecoder.startListening();
                    
                    // Connect audio recorder to decoder
                    this.audioRecorder.onAudioData((audioData) => {
                        this.audioDecoder.processAudioData(audioData);
                        
                        // Update audio level for visualization
                        this.updateAudioLevel(audioData);
                    });
                    
                    // Register decoder callbacks
                    this.setupDecoderCallbacks();
                    
                    // Show success message
                    this.showSuccess('âœ“ Listening for transmission... Waiting for audio signal.');
                    
                    // Start audio level visualization
                    this.audioVisualizer.startLevelMonitoring(() => this.currentAudioLevel);
                    
                } catch (error) {
                    this.handleReceiverError(error);
                }
            }

            /**
             * Update audio level from incoming audio data
             * @param {Float32Array} audioData - Audio samples
             */
            updateAudioLevel(audioData) {
                // Calculate RMS level
                let sum = 0;
                for (let i = 0; i < audioData.length; i++) {
                    sum += audioData[i] * audioData[i];
                }
                const rms = Math.sqrt(sum / audioData.length);
                
                // Smooth the level with exponential moving average
                const smoothing = 0.8;
                this.currentAudioLevel = (smoothing * this.currentAudioLevel) + ((1 - smoothing) * rms);
                
                // Clamp to 0-1 range
                this.currentAudioLevel = Math.min(Math.max(this.currentAudioLevel, 0), 1);
            }

            /**
             * Initialize sync event listeners
             */
            initializeSyncEventListeners() {
                const syncBtn = document.getElementById('receiverSyncBtn');
                
                if (syncBtn) {
                    syncBtn.addEventListener('click', () => {
                        this.handleSyncClick();
                    });
                }
                
                // Listen for sync state changes
                this.syncController.onStateChange((newState, oldState) => {
                    this.handleSyncStateChange(newState, oldState);
                });
                
                // Listen for frequency detection
                this.syncController.onFrequenciesDetectedCallback((frequencies) => {
                    this.handleFrequenciesDetected(frequencies);
                });
            }

            /**
             * Handle sync button click
             */
            async handleSyncClick() {
                const currentState = this.syncController.getSyncState();
                
                if (currentState === 'idle' || currentState === 'error' || currentState === 'detected') {
                    await this.startReceiverSync();
                } else if (currentState === 'listening') {
                    this.stopReceiverSync();
                }
            }

            /**
             * Start receiver sync listening
             */
            async startReceiverSync() {
                if (this.isSyncing || this.isReceiving) {
                    return;
                }
                
                try {
                    this.isSyncing = true;
                    
                    // Lock mode switching
                    this.modeController.lockMode();
                    
                    // Request microphone permission if not already granted
                    if (!this.audioRecorder.hasPermissionGranted()) {
                        try {
                            await this.audioRecorder.requestPermission();
                        } catch (permError) {
                            // Handle permission denied
                            throw new Error('Microphone permission denied. Please allow microphone access in your browser settings and try again.');
                        }
                    }
                    
                    // Create audio context for sync
                    this.syncAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Create spectrum analyzer
                    this.syncAnalyzer = new SpectrumAnalyzer(this.syncAudioContext, 8192);
                    
                    // Create frequency detector
                    this.syncDetector = new SyncFrequencyDetector();
                    
                    // Connect to microphone
                    const stream = this.audioRecorder.mediaStream;
                    if (!stream) {
                        throw new Error('No microphone stream available. Please ensure microphone access is granted.');
                    }
                    
                    const sourceNode = this.syncAudioContext.createMediaStreamSource(stream);
                    this.syncAnalyzer.connect(sourceNode);
                    
                    // Start sync state
                    await this.syncController.startReceiverSync();
                    
                    // Start periodic spectrum analysis (every 100ms)
                    this.syncInterval = setInterval(() => {
                        this.analyzeSpectrum();
                    }, 100);
                    
                    // Set 30-second timeout
                    this.syncTimeout = setTimeout(() => {
                        if (this.isSyncing) {
                            this.handleSyncTimeout();
                        }
                    }, 30000);
                    
                    // Update UI
                    this.syncUIManager.updateSyncStatus('listening', 'ðŸŽ§ Listening for calibration signal...');
                    
                } catch (error) {
                    this.handleSyncError(error);
                }
            }

            /**
             * Handle sync timeout
             */
            handleSyncTimeout() {
                this.syncUIManager.showSyncError({
                    type: 'timeout',
                    message: 'Sync timeout: No calibration signal detected within 30 seconds. Please ensure the emitter is transmitting and devices are close enough.'
                });
                this.stopReceiverSync();
            }

            /**
             * Handle sync errors
             * @param {Error} error - The error that occurred
             */
            handleSyncError(error) {
                let errorMessage = error.message || 'An unknown error occurred';
                let suggestions = [];
                
                // Determine error type and provide suggestions
                if (error.message.includes('permission') || error.message.includes('denied')) {
                    suggestions.push('Allow microphone access in your browser settings');
                    suggestions.push('Reload the page and try again');
                } else if (error.message.includes('microphone') || error.message.includes('stream')) {
                    suggestions.push('Check that your microphone is connected');
                    suggestions.push('Ensure no other application is using the microphone');
                } else {
                    suggestions.push('Try refreshing the page');
                    suggestions.push('Ensure your browser supports Web Audio API');
                }
                
                this.syncUIManager.showSyncError({
                    type: 'error',
                    message: errorMessage,
                    suggestions: suggestions
                });
                
                this.isSyncing = false;
                this.modeController.unlockMode();
                
                // Clean up
                if (this.syncInterval) {
                    clearInterval(this.syncInterval);
                    this.syncInterval = null;
                }
                if (this.syncTimeout) {
                    clearTimeout(this.syncTimeout);
                    this.syncTimeout = null;
                }
            }

            /**
             * Stop receiver sync listening
             */
            stopReceiverSync() {
                if (!this.isSyncing) {
                    return;
                }
                
                // Clear intervals and timeouts
                if (this.syncInterval) {
                    clearInterval(this.syncInterval);
                    this.syncInterval = null;
                }
                
                if (this.syncTimeout) {
                    clearTimeout(this.syncTimeout);
                    this.syncTimeout = null;
                }
                
                // Disconnect analyzer
                if (this.syncAnalyzer) {
                    this.syncAnalyzer.disconnect();
                    this.syncAnalyzer = null;
                }
                
                // Close audio context
                if (this.syncAudioContext) {
                    this.syncAudioContext.close();
                    this.syncAudioContext = null;
                }
                
                // Stop sync state
                this.syncController.stopReceiverSync();
                
                this.isSyncing = false;
                
                // Unlock mode switching
                this.modeController.unlockMode();
            }

            /**
             * Analyze spectrum for calibration frequencies
             */
            analyzeSpectrum() {
                if (!this.syncAnalyzer || !this.syncDetector) {
                    return;
                }
                
                try {
                    // Get frequency data
                    const spectrumData = this.syncAnalyzer.getFrequencyData();
                    
                    // Visualize spectrum
                    this.syncUIManager.displayFrequencySpectrum(spectrumData, this.syncAnalyzer);
                    
                    // Detect peaks in 4-8 kHz range
                    const peaks = this.syncDetector.detectPeaks(spectrumData, 4000, 8000, this.syncAnalyzer);
                    
                    // Highlight peaks
                    if (peaks.length > 0) {
                        this.syncUIManager.highlightDetectedPeaks(peaks, this.syncAnalyzer);
                    }
                    
                    // Try to identify calibration frequencies
                    const frequencies = this.syncDetector.identifyCalibrationFrequencies(peaks);
                    
                    if (frequencies) {
                        // Validate frequency separation
                        const isValid = this.syncDetector.validateFrequencies([
                            {frequency: frequencies.bit0},
                            {frequency: frequencies.preamble},
                            {frequency: frequencies.bit1}
                        ]);
                        
                        if (!isValid) {
                            // Frequencies too close together
                            this.syncUIManager.updateSyncStatus('listening', 
                                'âš  Detected frequencies too close together (< 500 Hz). Continuing to listen...');
                            return;
                        }
                        
                        if (frequencies.confidence > 0.7) {
                            // Successful detection with good confidence
                            this.syncController.onFrequenciesDetected(frequencies);
                        } else {
                            // Low confidence, keep listening
                            this.syncUIManager.updateSyncStatus('listening', 
                                `ðŸŽ§ Analyzing signal... (confidence: ${Math.round(frequencies.confidence * 100)}%)`);
                        }
                    }
                    
                    // Check for low signal
                    const avgMagnitude = peaks.length > 0 ? 
                        peaks.reduce((sum, p) => sum + p.magnitude, 0) / peaks.length : -80;
                    
                    if (avgMagnitude < -60 && peaks.length < 3) {
                        this.syncUIManager.updateSyncStatus('listening', 
                            'âš  Low signal level. Please increase volume or move devices closer.');
                    }
                    
                } catch (error) {
                    console.error('Error analyzing spectrum:', error);
                    // Don't stop sync on analysis errors, just log them
                }
            }

            /**
             * Handle detected frequencies
             * @param {Object} frequencies - Detected frequencies
             */
            handleFrequenciesDetected(frequencies) {
                try {
                    // Save previous configuration in case we need to restore it
                    const previousConfig = this.decoderConfigurator.getActiveFrequencies();
                    
                    // Stop sync listening
                    this.stopReceiverSync();
                    
                    // Update decoder with new frequencies
                    this.decoderConfigurator.updateFrequencies(this.audioDecoder, frequencies);
                    
                    // Display frequencies in UI
                    this.syncUIManager.displayDetectedFrequencies(frequencies);
                    
                    // Show success message
                    this.syncUIManager.showSyncSuccess();
                    
                } catch (error) {
                    console.error('Error handling detected frequencies:', error);
                    this.syncUIManager.showSyncError({
                        type: 'configuration',
                        message: 'Failed to apply detected frequencies. Previous configuration preserved.'
                    });
                    // Previous configuration is automatically preserved since update failed
                }
            }

            /**
             * Handle sync state changes
             * @param {string} newState - New sync state
             * @param {string} oldState - Previous sync state
             */
            handleSyncStateChange(newState, oldState) {
                // Update UI button state
                this.syncUIManager.updateSyncButtonState(newState);
            }

            /**
             * Set up decoder callbacks for chunk received and transmission complete
             */
            setupDecoderCallbacks() {
                // Callback for chunk received
                this.audioDecoder.onChunkReceived((chunk) => {
                    this.handleChunkReceived(chunk);
                });
                
                // Callback for transmission complete
                this.audioDecoder.onTransmissionComplete(() => {
                    this.handleTransmissionComplete();
                });
                
                // Callback for decoder errors
                this.audioDecoder.onError((error) => {
                    this.handleDecoderError(error);
                });
            }

            /**
             * Handle chunk received event
             * @param {Object} chunk - The received chunk
             */
            handleChunkReceived(chunk) {
                // Start reception if not already started
                if (!this.isReceiving) {
                    this.startReception();
                }
                
                // Update progress
                const header = this.audioDecoder.getHeader();
                if (header) {
                    const receivedChunks = this.audioDecoder.getReceivedChunks();
                    const bytesReceived = receivedChunks.reduce((sum, c) => sum + c.data.length, 0);
                    
                    // Update progress tracker
                    this.progressTracker.setTotal(header.totalSize);
                    this.progressTracker.updateProgress(bytesReceived);
                }
            }

            /**
             * Handle transmission complete event
             */
            handleTransmissionComplete() {
                try {
                    // Get all received chunks
                    const chunks = this.audioDecoder.getReceivedChunks();
                    const header = this.audioDecoder.getHeader();
                    
                    if (!header || chunks.length === 0) {
                        this.showError('Transmission incomplete: No data received. Please ensure the emitter is transmitting and try again.');
                        this.endReception();
                        return;
                    }
                    
                    // Check if we received all expected chunks
                    if (chunks.length < header.totalChunks) {
                        this.showError(
                            `Transmission incomplete: Received ${chunks.length} of ${header.totalChunks} chunks. ` +
                            'Some data may be missing. Please move devices closer together and try again.'
                        );
                        this.endReception();
                        return;
                    }
                    
                    // Reconstruct data from chunks
                    const reconstructedData = this.dataProcessor.reconstructData(chunks);
                    
                    // Verify reconstructed data size matches expected size
                    if (reconstructedData.length !== header.totalSize) {
                        this.showError(
                            `Data size mismatch: Expected ${header.totalSize} bytes but received ${reconstructedData.length} bytes. ` +
                            'The transmission may be corrupted. Please try again.'
                        );
                        this.endReception();
                        return;
                    }
                    
                    // Handle the received data based on type
                    if (header.type === 'text') {
                        this.handleReceivedText(reconstructedData);
                    } else if (header.type === 'file') {
                        this.handleReceivedFile(reconstructedData, header.filename);
                    }
                    
                    // Add to transmission history
                    this.transmissionHistory.push({
                        timestamp: new Date(),
                        type: header.type,
                        filename: header.filename,
                        size: reconstructedData.length,
                        data: reconstructedData
                    });
                    
                    // Show success message with details
                    const sizeKB = (reconstructedData.length / 1024).toFixed(2);
                    const typeLabel = header.type === 'text' ? 'Text' : 'File';
                    this.showSuccess(
                        `âœ“ ${typeLabel} received successfully! (${sizeKB} KB)` +
                        (header.filename ? ` - ${header.filename}` : '')
                    );
                    
                    // End reception
                    this.endReception();
                    
                } catch (error) {
                    this.showError('Failed to process received data: ' + error.message + ' Please try the transmission again.');
                    this.endReception();
                }
            }

            /**
             * Handle decoder errors
             * @param {Object} error - Error object from decoder
             */
            handleDecoderError(error) {
                let errorMessage = '';
                
                switch (error.type) {
                    case 'PREAMBLE_TIMEOUT':
                        errorMessage = 'â± ' + error.message;
                        break;
                    
                    case 'CHECKSUM_MISMATCH':
                        errorMessage = 'âš  ' + error.message;
                        if (error.receivedChunks > 0) {
                            errorMessage += ` (Received ${error.receivedChunks} of ${error.expectedChunks} chunks before errors occurred)`;
                        }
                        break;
                    
                    default:
                        errorMessage = 'âŒ Decoder error: ' + (error.message || 'Unknown error occurred');
                }
                
                this.showError(errorMessage);
                this.endReception();
                
                // Restart listening for next transmission
                setTimeout(() => {
                    this.audioDecoder.startListening();
                    this.hideStatus();
                }, 3000);
            }

            /**
             * Handle received text data
             * @param {Uint8Array} data - The received text data
             */
            handleReceivedText(data) {
                // Decode text from bytes
                const decoder = new TextDecoder();
                const text = decoder.decode(data);
                
                // Display text in UI
                this.displayText(text);
                
                // Add download button for text
                this.addTextDownloadButton(text);
            }

            /**
             * Handle received file data
             * @param {Uint8Array} data - The received file data
             * @param {string} filename - The original filename
             */
            handleReceivedFile(data, filename) {
                // Display file information in UI
                this.displayFileInfo(filename, data.length);
                
                // Automatically trigger download with filename preservation
                this.downloadFile(data, filename);
            }

            /**
             * Display text in the UI
             * @param {string} text - The text to display
             */
            displayText(text) {
                this.dataDisplay.classList.remove('empty');
                this.dataDisplay.textContent = text;
            }

            /**
             * Display file information in the UI
             * @param {string} filename - The filename
             * @param {number} size - The file size in bytes
             */
            displayFileInfo(filename, size) {
                this.dataDisplay.classList.remove('empty');
                
                const sizeKB = (size / 1024).toFixed(2);
                const info = `File received: ${filename}\nSize: ${sizeKB} KB\n\nDownload started automatically.`;
                
                this.dataDisplay.textContent = info;
            }

            /**
             * Add download button for text data
             * @param {string} text - The text to download
             */
            addTextDownloadButton(text) {
                // Create download button if it doesn't exist
                let downloadBtn = document.getElementById('textDownloadBtn');
                
                if (!downloadBtn) {
                    downloadBtn = document.createElement('button');
                    downloadBtn.id = 'textDownloadBtn';
                    downloadBtn.className = 'send-btn';
                    downloadBtn.textContent = 'Download as Text File';
                    downloadBtn.style.marginTop = '15px';
                    
                    // Insert after data display
                    this.dataDisplay.parentNode.insertBefore(
                        downloadBtn,
                        this.dataDisplay.nextSibling
                    );
                }
                
                // Update click handler
                downloadBtn.onclick = () => {
                    const encoder = new TextEncoder();
                    const data = encoder.encode(text);
                    this.downloadFile(data, 'received-text.txt');
                };
                
                // Show the button
                downloadBtn.style.display = 'block';
            }

            /**
             * Download file with filename preservation
             * @param {Uint8Array} data - The file data
             * @param {string} filename - The filename to use
             */
            downloadFile(data, filename) {
                try {
                    // Create a Blob from the data
                    const blob = new Blob([data], { type: 'application/octet-stream' });
                    
                    // Create a download link
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename || 'received-file';
                    
                    // Trigger download
                    document.body.appendChild(link);
                    link.click();
                    
                    // Clean up
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                    
                } catch (error) {
                    this.showError('Failed to download file: ' + error.message);
                }
            }

            /**
             * Start reception - update UI state
             */
            startReception() {
                this.isReceiving = true;
                
                // Lock mode switching
                this.modeController.lockMode();
                
                // Clear previous data display
                this.dataDisplay.classList.add('empty');
                this.dataDisplay.textContent = 'Receiving data...';
                
                // Hide any previous download button
                const downloadBtn = document.getElementById('textDownloadBtn');
                if (downloadBtn) {
                    downloadBtn.style.display = 'none';
                }
                
                // Clear status
                this.hideStatus();
                
                // Set up progress tracking
                this.progressTracker.clearCallbacks();
                this.progressTracker.onUpdate((progressInfo) => {
                    this.progressTracker.updateUI('receiver', progressInfo);
                });
            }

            /**
             * End reception - unlock UI and reset state
             */
            endReception() {
                this.isReceiving = false;
                
                // Unlock mode switching
                this.modeController.unlockMode();
                
                // Keep progress display visible to show final state
                // User can see 100% completion
            }

            /**
             * Handle receiver errors
             * @param {Error} error - The error that occurred
             */
            handleReceiverError(error) {
                let errorMessage = '';
                let instructions = '';
                
                if (error.message.includes('permission denied') || error.message.includes('Permission denied')) {
                    errorMessage = 'ðŸŽ¤ Microphone permission denied.';
                    instructions = 'Please click the microphone icon in your browser\'s address bar and allow access, then reload the page.';
                } else if (error.message.includes('No microphone found')) {
                    errorMessage = 'ðŸŽ¤ No microphone detected.';
                    instructions = 'Please connect a microphone to your device and reload the page.';
                } else if (error.message.includes('already in use')) {
                    errorMessage = 'ðŸŽ¤ Microphone is currently in use.';
                    instructions = 'Please close other applications using the microphone (like video calls or voice recorders) and reload the page.';
                } else if (error.message.includes('not supported') || error.message.includes('getUserMedia')) {
                    errorMessage = 'âŒ Web Audio API is not supported.';
                    instructions = 'Please use a modern browser like Chrome (version 34+), Firefox (version 25+), Safari (version 14+), or Edge.';
                } else {
                    errorMessage = 'âŒ Receiver initialization failed.';
                    instructions = error.message || 'An unknown error occurred. Please try refreshing the page.';
                }
                
                this.showError(errorMessage + ' ' + instructions);
                
                // Disable receiver mode if critical error
                this.modeController.unlockMode();
            }

            /**
             * Show success message
             * @param {string} message - Success message to display
             */
            showSuccess(message) {
                this.statusElement.textContent = message;
                this.statusElement.className = 'status-message success active';
            }

            /**
             * Show error message
             * @param {string} message - Error message to display
             */
            showError(message) {
                this.statusElement.textContent = message;
                this.statusElement.className = 'status-message error active';
            }

            /**
             * Hide status message
             */
            hideStatus() {
                this.statusElement.className = 'status-message';
                this.statusElement.textContent = '';
            }

            /**
             * Get transmission history
             * @returns {Array} Array of received transmissions
             */
            getTransmissionHistory() {
                return this.transmissionHistory;
            }

            /**
             * Clear transmission history
             */
            clearTransmissionHistory() {
                this.transmissionHistory = [];
            }
        }

        // Initialize the application
        let modeController, dataProcessor, inputHandler, emitterController, receiverController;

        // Wait for DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize core components
            modeController = new ModeController();
            dataProcessor = new DataProcessor();
            inputHandler = new InputHandler(dataProcessor);
            emitterController = new EmitterController(modeController, dataProcessor, inputHandler);
            
            // Initialize receiver controller when receiver mode is selected
            let receiverInitialized = false;
            
            // Override mode controller's setMode to initialize receiver on first use
            const originalSetMode = modeController.setMode.bind(modeController);
            modeController.setMode = function(mode) {
                originalSetMode(mode);
                
                // Initialize receiver controller when receiver mode is first selected
                if (mode === 'receiver' && !receiverInitialized) {
                    receiverController = new ReceiverController(modeController, dataProcessor);
                    receiverInitialized = true;
                }
            };
        });
    </script>
</body>
</html>
